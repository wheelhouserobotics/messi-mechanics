{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\nimport math\n\nclass GameElements:\n    MOBILE_GOAL = 0\n    RED_RING = 1\n    BLUE_RING = 2\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nleft_motor_a = Motor(Ports.PORT21, GearSetting.RATIO_6_1, True)\nleft_motor_b = Motor(Ports.PORT2, GearSetting.RATIO_6_1, True)\nleft_motor_c = Motor(Ports.PORT19, GearSetting.RATIO_6_1, True)\nleft_drive_smart = MotorGroup(left_motor_a, left_motor_b, left_motor_c)\nright_motor_a = Motor(Ports.PORT18, GearSetting.RATIO_6_1, False)\nright_motor_b = Motor(Ports.PORT17, GearSetting.RATIO_6_1, False)\nright_motor_c = Motor(Ports.PORT4, GearSetting.RATIO_6_1, False)\nright_drive_smart = MotorGroup(right_motor_a, right_motor_b, right_motor_c)\ndrivetrain = DriveTrain(left_drive_smart, right_drive_smart, 319.19, 295, 40, MM, 1)\n\n# Intake & scoring\nintake_belt = Motor(Ports.PORT5, GearSetting.RATIO_6_1, False)\nintake_wheels = Motor(Ports.PORT16, GearSetting.RATIO_18_1, True)\n\n# Vision sensor\nai_vision_sensor = AiVision(Ports.PORT3, AiVision.ALL_AIOBJS)\ngps_sensor = Gps(Ports.PORT15, 101.60, -177.80, MM, 0)\n\n# Digital outputs\nleftClear = DigitalOut(brain.three_wire_port.e)\nrightClear = DigitalOut(brain.three_wire_port.f)\nmogoPiston1 = DigitalOut(brain.three_wire_port.g)\nmogoPiston2 = DigitalOut(brain.three_wire_port.h)\n\n# Updated rotation sensors - using straight and turn rotation\nturn_rotation = Rotation(Ports.PORT9, False)\nstraight_rotation = Rotation(Ports.PORT13, False)\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n# Make random actually random\ndef initializeRandomSeed():\n    wait(100, MSEC)\n    random = brain.battery.voltage(MV) + brain.battery.current(CurrentUnits.AMP) * 100 + brain.timer.system_high_res()\n    urandom.seed(int(random))\n      \n# Set random seed \ninitializeRandomSeed()\n\ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(200, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n\n#endregion VEXcode Generated Robot Configuration\n\n# Brain should be defined by default\nbrain = Brain()\n\n# Parameters for turning PID control\nturn_kP = 0.35    # Proportional constant\nturn_kI = 0.001   # Integral constant\nturn_kD = 0.03    # Derivative constant\nturn_tolerance = 1.0  # Acceptable error in degrees\nmin_turn_speed = 10  # Minimum turn speed to overcome friction\nmax_turn_speed = 30  # Maximum turn speed\n\n# Enhanced backup system constants\nSTUCK_THRESHOLD = 5  # degrees of movement required to not be considered stuck\nBACKUP_CHECK_INTERVAL = 300  # milliseconds between stuck checks\nBACKUP_DISTANCE = 200  # degrees to backup when stuck\nBACKUP_SPEED = 50  # speed for backup maneuver\nBACKUP_TURN_RANGE = (-60, 60)  # range of random turn angles after backup\nMAX_BACKUP_ATTEMPTS = 3  # maximum backup attempts before giving up\n\ndef normalize_heading(heading):\n    \"\"\"Normalize heading to be between 0-360 degrees\"\"\"\n    while heading < 0:\n        heading += 360\n    while heading >= 360:\n        heading -= 360\n    return heading\n\ndef shortest_angle_difference(target, current):\n    \"\"\"Calculate the shortest angle to turn (handles wraparound)\"\"\"\n    diff = normalize_heading(target) - normalize_heading(current)\n    if diff > 180:\n        diff -= 360\n    elif diff < -180:\n        diff += 360\n    return diff\n\ndef turn_to_heading(target_heading, max_speed):\n    \"\"\"Turn the robot to a specific heading using PID control with GPS sensor\"\"\"\n    if not gps_sensor.installed():\n        print(\"Error: GPS sensor not detected\")\n        return False\n\n    print(\"Starting turn to heading: \" + str(target_heading) + \" degrees\")\n    target_heading = normalize_heading(target_heading)\n    integral = 0\n    prev_error = 0\n    current_heading = gps_sensor.heading()\n    error = shortest_angle_difference(target_heading, current_heading)\n    timer = Timer()\n    timer.reset()\n    max_time = 3  # seconds\n    start_time = brain.timer.time(SECONDS)\n    stall_count = 0\n    max_stalls = 3\n\n    while abs(error) > turn_tolerance:\n        if brain.timer.time(SECONDS) - start_time > max_time:\n            print(\"Turn timeout - breaking out of turn\")\n            break\n\n        current_heading = gps_sensor.heading()\n        error = shortest_angle_difference(target_heading, current_heading)\n        integral += error\n        if abs(integral) > 1000:\n            integral = 1000 if integral > 0 else -1000\n\n        if timer.time(SECONDS) > 1.5:\n            if abs(prev_error - error) < 1:\n                integral = 0\n                print(\"Progress stalled, resetting integral\")\n                stall_count += 1\n                if stall_count >= max_stalls:\n                    print(\"Too many stalls, breaking out of turn\")\n                    break\n            timer.reset()\n\n        derivative = error - prev_error\n        power = (error * turn_kP) + (integral * turn_kI) + (derivative * turn_kD)\n        if 0 < abs(power) < min_turn_speed:\n            power = min_turn_speed * (1 if power > 0 else -1)\n        if abs(power) > max_speed:\n            power = max_speed * (1 if power > 0 else -1)\n\n        left_drive_smart.spin(FORWARD, power, PERCENT)\n        right_drive_smart.spin(REVERSE, power, PERCENT)\n        prev_error = error\n        wait(20, MSEC)\n\n    left_drive_smart.stop(BRAKE)\n    right_drive_smart.stop(BRAKE)\n    print(\"Turn complete: Current= \" + str(round(gps_sensor.heading(), 1)) + \", Target= \" + str(target_heading))\n    return True\n\ndef turn_by_angle(angle_degrees, max_speed):\n    \"\"\"Turn the robot by a specific angle using the turn rotation sensor\"\"\"\n    if not turn_rotation.installed():\n        print(\"Error: Turn rotation sensor not detected\")\n        return False\n\n    # Reset turn rotation sensor\n    turn_rotation.reset_position()\n    target_angle = abs(angle_degrees)\n    direction = 1 if angle_degrees > 0 else -1\n    \n    print(\"Starting relative turn of \" + str(angle_degrees) + \" degrees using turn sensor\")\n    \n    integral = 0\n    prev_error = target_angle\n    start_time = brain.timer.time(SECONDS)\n    max_time = 3  # seconds timeout\n    \n    while abs(turn_rotation.position(DEGREES)) < target_angle:\n        if brain.timer.time(SECONDS) - start_time > max_time:\n            print(\"Turn timeout - breaking out\")\n            break\n            \n        current_angle = abs(turn_rotation.position(DEGREES))\n        error = target_angle - current_angle\n        \n        integral += error\n        if abs(integral) > 500:\n            integral = 500 if integral > 0 else -500\n            \n        derivative = error - prev_error\n        power = (error * 0.8) + (integral * 0.001) + (derivative * 0.1)\n        \n        # Apply minimum and maximum power limits\n        if 0 < abs(power) < min_turn_speed:\n            power = min_turn_speed * (1 if power > 0 else -1)\n        if abs(power) > max_speed:\n            power = max_speed * (1 if power > 0 else -1)\n            \n        # Apply direction\n        power *= direction\n        \n        left_drive_smart.spin(FORWARD, power, PERCENT)\n        right_drive_smart.spin(REVERSE, power, PERCENT)\n        \n        prev_error = error\n        wait(20, MSEC)\n    \n    left_drive_smart.stop(BRAKE)\n    right_drive_smart.stop(BRAKE)\n    \n    final_angle = turn_rotation.position(DEGREES)\n    print(\"Turn complete: Rotated \" + str(round(final_angle, 1)) + \" degrees\")\n    return True\n\n# PID constants for straight driving\nstraight_kP = 0.8   # Proportional gain for distance control\nstraight_kI = 0.01  # Integral gain\nstraight_kD = 0.1   # Derivative gain\nheading_kP = 1.2    # Proportional gain for heading correction\nMAX_INTEGRAL = 50\n\ndef reset_rotations():\n    \"\"\"Reset rotation sensors\"\"\"\n    if not (turn_rotation.installed() and straight_rotation.installed()):\n        print(\"Error: Rotation sensors not detected\")\n        return False\n    turn_rotation.reset_position()\n    straight_rotation.reset_position()\n    return True\n\ndef is_robot_stuck(check_duration_ms=500, min_movement=STUCK_THRESHOLD):\n    \"\"\"Enhanced stuck detection using rotation sensors with configurable parameters\"\"\"\n    if not straight_rotation.installed():\n        print(\"Warning: Cannot check if stuck - straight rotation sensor not available\")\n        return False\n    \n    initial_straight_pos = straight_rotation.position(DEGREES)\n    initial_turn_pos = turn_rotation.position(DEGREES) if turn_rotation.installed() else 0\n    \n    wait(check_duration_ms, MSEC)\n    \n    final_straight_pos = straight_rotation.position(DEGREES)\n    final_turn_pos = turn_rotation.position(DEGREES) if turn_rotation.installed() else 0\n    \n    straight_movement = abs(final_straight_pos - initial_straight_pos)\n    turn_movement = abs(final_turn_pos - initial_turn_pos)\n    total_movement = straight_movement + turn_movement\n    \n    is_stuck = total_movement < min_movement\n    \n    if is_stuck:\n        print(\"Robot stuck detected - Movement: \" + str(round(total_movement, 1)) + \" degrees\")\n    \n    return is_stuck\n\ndef enhanced_backup_from_obstacle():\n    \"\"\"Enhanced backup maneuver with multiple strategies when robot hits an obstacle\"\"\"\n    print(\"*** OBSTACLE DETECTED - INITIATING ENHANCED BACKUP ***\")\n    \n    # Stop all motors immediately\n    left_drive_smart.stop(BRAKE)\n    right_drive_smart.stop(BRAKE)\n    \n    # Temporarily stop intake to prevent jamming\n    intake_belt.stop()\n    intake_wheels.stop()\n    \n    wait(200, MSEC)  # Brief pause to assess situation\n    \n    # Strategy 1: Simple reverse backup\n    print(\"Backup Step 1: Reversing\")\n    if straight_rotation.installed():\n        straight_rotation.reset_position()\n    \n    left_drive_smart.spin(REVERSE, BACKUP_SPEED, PERCENT)\n    right_drive_smart.spin(REVERSE, BACKUP_SPEED, PERCENT)\n    \n    # Monitor backup progress\n    backup_timer = Timer()\n    backup_timer.reset()\n    backup_timeout = 2.0  # seconds\n    backup_success = False\n    \n    while backup_timer.time(SECONDS) < backup_timeout:\n        if straight_rotation.installed():\n            backup_distance = abs(straight_rotation.position(DEGREES))\n            if backup_distance >= BACKUP_DISTANCE:\n                backup_success = True\n                break\n        wait(50, MSEC)\n    \n    left_drive_smart.stop(BRAKE)\n    right_drive_smart.stop(BRAKE)\n    \n    if backup_success:\n        print(\"Backup successful - moved \" + str(round(backup_distance, 1)) + \" degrees\")\n    else:\n        print(\"Backup may be limited - attempting alternative maneuver\")\n        \n        # Strategy 2: Oscillating backup (rock back and forth)\n        print(\"Backup Step 2: Oscillating maneuver\")\n        for i in range(3):  # Try 3 oscillations\n            # Forward push\n            left_drive_smart.spin(FORWARD, 30, PERCENT)\n            right_drive_smart.spin(FORWARD, 30, PERCENT)\n            wait(300, MSEC)\n            left_drive_smart.stop(BRAKE)\n            right_drive_smart.stop(BRAKE)\n            \n            # Backward pull\n            left_drive_smart.spin(REVERSE, BACKUP_SPEED, PERCENT)\n            right_drive_smart.spin(REVERSE, BACKUP_SPEED, PERCENT)\n            wait(500, MSEC)\n            left_drive_smart.stop(BRAKE)\n            right_drive_smart.stop(BRAKE)\n            \n            # Check if we're now free\n            if not is_robot_stuck(300, STUCK_THRESHOLD/2):\n                print(\"Oscillating maneuver successful\")\n                break\n        \n        # Strategy 3: Angled backup\n        print(\"Backup Step 3: Angled escape maneuver\")\n        escape_angle = urandom.randint(-30, 30)\n        \n        # Turn slightly while backing up\n        left_speed = BACKUP_SPEED + (escape_angle * 0.5)\n        right_speed = BACKUP_SPEED - (escape_angle * 0.5)\n        \n        # Clamp speeds\n        left_speed = max(min(left_speed, 80), -80)\n        right_speed = max(min(right_speed, 80), -80)\n        \n        left_drive_smart.spin(REVERSE, abs(left_speed), PERCENT)\n        right_drive_smart.spin(REVERSE, abs(right_speed), PERCENT)\n        wait(800, MSEC)\n        left_drive_smart.stop(BRAKE)\n        right_drive_smart.stop(BRAKE)\n    \n    # Final repositioning turn\n    print(\"Backup Step 4: Repositioning turn\")\n    random_turn = urandom.randint(BACKUP_TURN_RANGE[0], BACKUP_TURN_RANGE[1])\n    turn_by_angle(random_turn, 35)\n    \n    # Small forward movement to test if path is clear\n    print(\"Backup Step 5: Testing forward movement\")\n    if straight_rotation.installed():\n        straight_rotation.reset_position()\n    \n    left_drive_smart.spin(FORWARD, 25, PERCENT)\n    right_drive_smart.spin(FORWARD, 25, PERCENT)\n    wait(400, MSEC)\n    left_drive_smart.stop(BRAKE)\n    right_drive_smart.stop(BRAKE)\n    \n    # Restart intake motors\n    intake_belt.spin(FORWARD, 85, PERCENT)\n    intake_wheels.spin(FORWARD, 85, PERCENT)\n    \n    print(\"*** BACKUP MANEUVER COMPLETE ***\")\n    \n    # Verify we're no longer stuck\n    final_check = is_robot_stuck(200, STUCK_THRESHOLD/2)\n    if final_check:\n        print(\"Warning: Robot may still be stuck after backup\")\n        return False\n    else:\n        print(\"Backup successful - robot is free to move\")\n        return True\n\ndef drive_straight_pid(distance_deg, speed_pct):\n    \"\"\"Drive straight for a specific distance using straight rotation sensor with enhanced stuck detection\"\"\"\n    if not reset_rotations():\n        return False\n    \n    if not gps_sensor.installed():\n        print(\"Warning: GPS sensor not available for heading correction\")\n        return drive_straight_basic(distance_deg, speed_pct)\n\n    target_distance = abs(distance_deg)\n    direction = 1 if distance_deg > 0 else -1\n    initial_heading = gps_sensor.heading()\n    \n    # PID variables for distance control\n    distance_integral = 0\n    prev_distance_error = target_distance\n    \n    max_time = 6  # seconds\n    start_time = brain.timer.time(SECONDS)\n    last_time = brain.timer.time(MSEC)\n    last_stuck_check = brain.timer.time(MSEC)\n    backup_attempts = 0\n\n    print(\"Starting straight drive: \" + str(distance_deg) + \" degrees at \" + str(speed_pct) + \"% speed\")\n    print(\"Initial heading: \" + str(round(initial_heading, 1)) + \" degrees\")\n\n    while abs(straight_rotation.position(DEGREES)) < target_distance:\n        current_time_sec = brain.timer.time(SECONDS)\n        current_time_ms = brain.timer.time(MSEC)\n        \n        # Check for timeout\n        if current_time_sec - start_time > max_time:\n            print(\"Drive timeout - breaking out\")\n            break\n\n        # Periodic stuck check during movement\n        if current_time_ms - last_stuck_check > BACKUP_CHECK_INTERVAL:\n            if is_robot_stuck(200, STUCK_THRESHOLD/2):\n                print(\"Robot stuck during drive - attempting backup\")\n                if enhanced_backup_from_obstacle():\n                    backup_attempts += 1\n                    if backup_attempts >= MAX_BACKUP_ATTEMPTS:\n                        print(\"Max backup attempts reached - aborting drive\")\n                        break\n                    # Reset timers after backup\n                    start_time = brain.timer.time(SECONDS)\n                    last_time = brain.timer.time(MSEC)\n                else:\n                    print(\"Backup failed - aborting drive\")\n                    break\n            last_stuck_check = current_time_ms\n\n        dt = max(current_time_ms - last_time, 1)\n        last_time = current_time_ms\n\n        # Get current position and heading\n        current_distance = abs(straight_rotation.position(DEGREES))\n        current_heading = gps_sensor.heading()\n        \n        # Distance PID control\n        distance_error = target_distance - current_distance\n        distance_integral += distance_error * dt / 1000.0\n        distance_integral = max(min(distance_integral, MAX_INTEGRAL), -MAX_INTEGRAL)\n        distance_derivative = (distance_error - prev_distance_error) / (dt / 1000.0)\n        \n        distance_output = (distance_error * straight_kP + \n                          distance_integral * straight_kI + \n                          distance_derivative * straight_kD)\n        \n        # Heading correction\n        heading_error = shortest_angle_difference(initial_heading, current_heading)\n        heading_correction = heading_error * heading_kP\n        \n        # Calculate motor speeds with heading correction\n        base_speed = min(abs(distance_output), speed_pct) * direction\n        left_speed = base_speed - heading_correction\n        right_speed = base_speed + heading_correction\n        \n        # Clamp motor speeds\n        left_speed = max(min(left_speed, 100), -100)\n        right_speed = max(min(right_speed, 100), -100)\n\n        left_drive_smart.set_velocity(left_speed, PERCENT)\n        right_drive_smart.set_velocity(right_speed, PERCENT)\n        left_drive_smart.spin(FORWARD)\n        right_drive_smart.spin(FORWARD)\n\n        prev_distance_error = distance_error\n        \n        progress_percent = (current_distance / target_distance * 100)\n        print(\"Distance: \" + str(round(current_distance, 1)) + \"/\" + str(target_distance) + \n              \" Heading: \" + str(round(current_heading, 1)) + \n              \" Progress: \" + str(round(progress_percent, 1)) + \"%\")\n        wait(20, MSEC)\n\n    left_drive_smart.stop(BRAKE)\n    right_drive_smart.stop(BRAKE)\n    \n    final_distance = straight_rotation.position(DEGREES)\n    final_heading = gps_sensor.heading()\n    print(\"Drive complete! Distance: \" + str(round(final_distance, 1)) + \" degrees\")\n    print(\"Final heading: \" + str(round(final_heading, 1)) + \" degrees\")\n    return True\n\ndef drive_straight_basic(distance_deg, speed_pct):\n    \"\"\"Basic straight drive without GPS heading correction (fallback) with stuck detection\"\"\"\n    if not straight_rotation.installed():\n        print(\"Error: Straight rotation sensor not detected\")\n        return False\n    \n    straight_rotation.reset_position()\n    target_distance = abs(distance_deg)\n    direction = 1 if distance_deg > 0 else -1\n    \n    print(\"Basic straight drive: \" + str(distance_deg) + \" degrees\")\n    \n    # Use turn rotation sensor for basic drift correction\n    if turn_rotation.installed():\n        turn_rotation.reset_position()\n    \n    last_stuck_check = brain.timer.time(MSEC)\n    backup_attempts = 0\n    \n    while abs(straight_rotation.position(DEGREES)) < target_distance:\n        current_time_ms = brain.timer.time(MSEC)\n        current_distance = abs(straight_rotation.position(DEGREES))\n        \n        # Periodic stuck check\n        if current_time_ms - last_stuck_check > BACKUP_CHECK_INTERVAL:\n            if is_robot_stuck(200, STUCK_THRESHOLD/2):\n                print(\"Robot stuck during basic drive - attempting backup\")\n                if enhanced_backup_from_obstacle():\n                    backup_attempts += 1\n                    if backup_attempts >= MAX_BACKUP_ATTEMPTS:\n                        print(\"Max backup attempts reached - aborting drive\")\n                        break\n                else:\n                    print(\"Backup failed - aborting drive\")\n                    break\n            last_stuck_check = current_time_ms\n        \n        # Basic drift correction using turn sensor if available\n        if turn_rotation.installed():\n            turn_drift = turn_rotation.position(DEGREES)\n            correction = turn_drift * 0.5  # Small correction factor\n            \n            left_speed = speed_pct * direction - correction\n            right_speed = speed_pct * direction + correction\n            \n            left_speed = max(min(left_speed, 100), -100)\n            right_speed = max(min(right_speed, 100), -100)\n        else:\n            left_speed = speed_pct * direction\n            right_speed = speed_pct * direction\n        \n        left_drive_smart.set_velocity(left_speed, PERCENT)\n        right_drive_smart.set_velocity(right_speed, PERCENT)\n        left_drive_smart.spin(FORWARD)\n        right_drive_smart.spin(FORWARD)\n        \n        progress_percent = (current_distance / target_distance * 100)\n        print(\"Progress: \" + str(round(progress_percent, 1)) + \"%\")\n        wait(20, MSEC)\n    \n    left_drive_smart.stop(BRAKE)\n    right_drive_smart.stop(BRAKE)\n    print(\"Basic drive complete!\")\n    return True\n\ndef drive_distance_with_timeout(distance_deg, speed_pct, timeout_sec):\n    \"\"\"Drive with timeout handling and enhanced stuck detection\"\"\"\n    wait(100, MSEC)\n    timer = Timer()\n    timer.reset()\n    success = drive_straight_pid(distance_deg, speed_pct)\n    if timer.time(SECONDS) >= timeout_sec:\n        print(\"Drive timed out!\")\n        left_drive_smart.stop(BRAKE)\n        right_drive_smart.stop(BRAKE)\n        return False\n    return success\n\ndef calculate_timeout(distance_mm, speed_percent):\n    \"\"\"Calculate timeout based on distance and speed\"\"\"\n    max_speed = 500  # mm/s at 100% speed (adjust based on robot testing)\n    actual_speed = (speed_percent / 100) * max_speed\n    timeout = (distance_mm / actual_speed) * 1.5\n    return max(timeout, 1.0)\n\ndef backup_from_obstacle():\n    \"\"\"Legacy backup function - now calls enhanced version\"\"\"\n    return enhanced_backup_from_obstacle()\n\n# Constants for navigation\nwheelDiameter = 2.75  # Inches\nwheelCircumference = math.pi * wheelDiameter\ntravelDistance = 48  # Inches\nerror_margin = 5  # Inches\nnumberOfDegrees = ((travelDistance - error_margin) / wheelCircumference) * 360\n\n# Dynamic movement distances based on ring size\nSMALL_MOVE = numberOfDegrees / 4    # Quarter move for fine adjustments\nMEDIUM_MOVE = numberOfDegrees / 2   # Half move for medium adjustments\nLARGE_MOVE = numberOfDegrees        # Full move for large movements\n\n# Vision and alignment constants\nVISION_CENTER_X = 160  # Center of 320px vision sensor\nALIGNMENT_TOLERANCE = 8  # Pixels - tighter tolerance for better alignment\nFINE_ALIGNMENT_TOLERANCE = 5  # Even tighter for final approach\nVISION_SAMPLES = 2  # Number of snapshots to take for reliability\n\n# Ring size thresholds for different approach strategies\nRING_COLLECT_SIZE = 120    # Size when ring is ready to collect\nRING_CLOSE_SIZE = 80       # Size when ring is close\nRING_MEDIUM_SIZE = 40      # Size when ring is at medium distance\nRING_FAR_SIZE = 20         # Minimum size to consider ring visible\n\ndef get_reliable_vision_data(samples=VISION_SAMPLES):\n    \"\"\"Take multiple snapshots for better detection reliability\"\"\"\n    best_blue_rings = []\n    best_red_rings = []\n    \n    for i in range(samples):\n        objs = ai_vision_sensor.take_snapshot(AiVision.ALL_AIOBJS)\n        if objs:\n            blue_rings = [obj for obj in objs if obj.id == GameElements.BLUE_RING]\n            red_rings = [obj for obj in objs if obj.id == GameElements.RED_RING]\n            \n            # Keep the sample with the most rings total\n            current_total = len(blue_rings) + len(red_rings)\n            best_total = len(best_blue_rings) + len(best_red_rings)\n            \n            if current_total > best_total:\n                best_blue_rings = blue_rings\n                best_red_rings = red_rings\n            elif current_total == best_total and current_total > 0:\n                # If same count, prefer the one with larger rings\n                current_rings = blue_rings + red_rings\n                best_rings = best_blue_rings + best_red_rings\n                \n                if current_rings and best_rings:\n                    current_max = max(current_rings, key=lambda x: x.width).width\n                    best_max = max(best_rings, key=lambda x: x.width).width\n                    if current_max > best_max:\n                        best_blue_rings = blue_rings\n                        best_red_rings = red_rings\n        \n        if i < samples - 1:  # Don't wait after last sample\n            wait(50, MSEC)\n    \n    return best_blue_rings, best_red_rings\n\ndef calculate_turn_angle(error, ring_width):\n    \"\"\"Calculate proportional turn angle based on error and ring distance\"\"\"\n    # Base turn angle proportional to error\n    base_angle = error * 0.25  # Scale factor - adjust as needed\n    \n    # Adjust turn angle based on ring distance (larger rings = smaller turns)\n    if ring_width > RING_CLOSE_SIZE:\n        # Ring is close, use smaller adjustments\n        angle_multiplier = 0.5\n    elif ring_width > RING_MEDIUM_SIZE:\n        # Ring is medium distance, use normal adjustments\n        angle_multiplier = 1.0\n    else:\n        # Ring is far, use larger adjustments\n        angle_multiplier = 1.5\n    \n    turn_angle = base_angle * angle_multiplier\n    \n    # Clamp turn angle to reasonable range\n    turn_angle = max(-35, min(35, turn_angle))\n    \n    # Ensure minimum turn for small errors to overcome friction\n    if 0 < abs(turn_angle) < 5:\n        turn_angle = 5 if turn_angle > 0 else -5\n    \n    return turn_angle\n\ndef align_to_ring(target_ring, tolerance=ALIGNMENT_TOLERANCE):\n    \"\"\"Improved ring alignment with proportional control\"\"\"\n    center_x = target_ring.centerX\n    ring_width = target_ring.width\n    error = center_x - VISION_CENTER_X\n    \n    ring_color = \"BLUE\" if target_ring.id == GameElements.BLUE_RING else \"RED\"\n    print(\"Aligning to \" + ring_color + \" ring - Center: \" + str(center_x) + \", Width: \" + str(ring_width) + \", Error: \" + str(error))\n    \n    if abs(error) <= tolerance:\n        print(\"Ring already aligned!\")\n        return True\n    \n    turn_angle = calculate_turn_angle(error, ring_width)\n    print(\"Calculated turn angle: \" + str(round(turn_angle, 1)) + \" degrees\")\n    \n    # Perform the turn\n    turn_by_angle(turn_angle, 25)\n    wait(200, MSEC)  # Allow time for movement to settle\n    \n    return False\n\ndef get_approach_strategy(ring_width):\n    \"\"\"Determine approach strategy based on ring size\"\"\"\n    if ring_width >= RING_COLLECT_SIZE:\n        return \"collect\", 0, 25  # action, distance, speed\n    elif ring_width >= RING_CLOSE_SIZE:\n        return \"slow_approach\", SMALL_MOVE, 25\n    elif ring_width >= RING_MEDIUM_SIZE:\n        return \"medium_approach\", MEDIUM_MOVE, 35\n    elif ring_width >= RING_FAR_SIZE:\n        return \"fast_approach\", LARGE_MOVE, 45\n    else:\n        return \"not_visible\", 0, 0\n\ndef select_best_target_ring(blue_rings, red_rings):\n    \"\"\"Select the best ring to target from all available rings\"\"\"\n    all_rings = blue_rings + red_rings\n    \n    if not all_rings:\n        return None\n    \n    # Priority: Largest ring (closest) first\n    target_ring = max(all_rings, key=lambda x: x.width)\n    \n    ring_color = \"BLUE\" if target_ring.id == GameElements.BLUE_RING else \"RED\"\n    print(\"Selected \" + ring_color + \" ring as target - Width: \" + str(target_ring.width) + \", Center: \" + str(target_ring.centerX))\n    \n    return target_ring\n\ndef perform_scanning_rotation(scan_angle=30, scan_speed=5):\n \"\"\"Perform controlled scanning rotation to find rings\"\"\"\n print(\"Scanning for rings - rotating \" + str(scan_angle) + \" degrees...\")\n turn_by_angle(scan_angle, scan_speed)\n wait(300, MSEC) # Allow time for vision to stabilize\n\n\n\n\n\n\ndef check_blue_obstruction(blue_rings, target_ring):\n    \"\"\"Check if any blue rings are obstructing the path to target red ring\"\"\"\n    if not blue_rings:\n        return False, None\n    \n    target_center_x = target_ring.centerX\n    target_width = target_ring.width\n    \n    for blue_ring in blue_rings:\n        blue_center_x = blue_ring.centerX\n        blue_width = blue_ring.width\n        \n        # Check if blue ring is significantly closer (larger) and in the path\n        if (blue_width > target_width * 1.2 and \n            abs(blue_center_x - target_center_x) < 60):\n            print(\"Blue ring obstruction detected - Width: \" + str(blue_width) + \", Center: \" + str(blue_center_x))\n            return True, blue_ring\n    \n    return False, None\n\ndef avoid_blue_obstruction(obstructing_blue, target_red):\n    \"\"\"Avoid blue ring obstruction to reach red ring\"\"\"\n    blue_center = obstructing_blue.centerX\n    red_center = target_red.centerX\n    \n    # Determine which side to go around the blue ring\n    if blue_center < VISION_CENTER_X:\n        # Blue ring is on left, go right\n        avoidance_angle = 25\n        print(\"Avoiding blue ring by turning right\")\n    else:\n        # Blue ring is on right, go left\n        avoidance_angle = -25\n        print(\"Avoiding blue ring by turning left\")\n    \n    # Execute avoidance maneuver\n    turn_by_angle(avoidance_angle, 30)\n    wait(200, MSEC)\n    \n    # Move forward to get around the obstruction\n    drive_distance_with_timeout(SMALL_MOVE, 35, calculate_timeout(100, 35))\n    \n    # Turn back toward the red ring\n    turn_by_angle(-avoidance_angle * 0.7, 30)  # Turn back, but not fully\n    wait(200, MSEC)\n\ndef main():\n    \"\"\"Enhanced main program with perfect 360-degree clockwise scanning for RED rings\"\"\"\n    if not gps_sensor.installed():\n        print(\"Warning: GPS sensor not detected - using basic navigation\")\n    if not ai_vision_sensor.installed():\n        print(\"Error: AI Vision sensor not detected\")\n        return\n    if not (turn_rotation.installed() and straight_rotation.installed()):\n        print(\"Error: Rotation sensors not detected\")\n        return\n\n    print(\"Starting enhanced 360-degree RED ring detection and navigation program\")\n    rings_collected = 0\n    stuck_counter = 0\n    max_stuck_count = 3\n    max_rings = 5  # Exit condition\n    \n    # 360-degree scanning parameters\n    SCAN_INCREMENT = 30  # Degrees to turn each scan step\n    TOTAL_SCAN_DEGREES = 360\n    scan_steps = TOTAL_SCAN_DEGREES // SCAN_INCREMENT  # 12 steps for full 360\n    current_scan_step = 0\n    \n    # Forward movement parameters when no rings found\n    SEARCH_MOVE_DISTANCE = MEDIUM_MOVE  # Distance to move forward when searching\n    no_rings_cycles = 0\n    max_no_rings_cycles = 3  # Max cycles of 360 scans before moving forward\n\n    # Start intake motors\n    intake_belt.spin(FORWARD, 85, PERCENT)\n    intake_wheels.spin(FORWARD, 85, PERCENT)\n\n    # Set drivetrain speeds\n    drivetrain.set_turn_velocity(30, PERCENT)\n    drivetrain.set_drive_velocity(30, PERCENT)\n    \n    # Record initial heading for reference\n    if gps_sensor.installed():\n        initial_heading = gps_sensor.heading()\n        print(\"Initial heading: \" + str(round(initial_heading, 1)) + \" degrees\")\n\n    while rings_collected < max_rings:\n        print(\"\\n=== SCAN CYCLE \" + str(rings_collected + 1) + \" ===\")\n        print(\"Red rings collected: \" + str(rings_collected))\n        print(\"Scan step: \" + str(current_scan_step + 1) + \"/\" + str(scan_steps))\n        if gps_sensor.installed():\n            print(\"GPS heading: \" + str(round(gps_sensor.heading(), 1)) + \" degrees\")\n        print(\"Battery voltage: \" + str(round(brain.battery.voltage(VOLT), 1)) + \" V\")\n        \n        # Get vision data with multiple samples for reliability\n        blue_rings, red_rings = get_reliable_vision_data()\n\n        if not red_rings:\n            print(\"No red rings detected in scan step \" + str(current_scan_step + 1))\n            \n            # Continue clockwise scanning\n            current_scan_step += 1\n            \n            if current_scan_step >= scan_steps:\n                # Completed full 360-degree scan without finding rings\n                print(\"Completed 360-degree scan - no red rings found\")\n                no_rings_cycles += 1\n                current_scan_step = 0  # Reset scan step counter\n                \n                if no_rings_cycles >= max_no_rings_cycles:\n                    print(\"Moving forward to search new area...\")\n                    # Move forward to explore new area\n                    success = drive_distance_with_timeout(SEARCH_MOVE_DISTANCE, 40, \n                                                        calculate_timeout(SEARCH_MOVE_DISTANCE * 2, 40))\n                    \n                    if not success or is_robot_stuck():\n                        print(\"Forward movement failed - attempting backup\")\n                        backup_from_obstacle()\n                    \n                    no_rings_cycles = 0  # Reset no-rings cycle counter\n                    print(\"Starting new 360-degree scan from new position\")\n                else:\n                    print(\"Starting scan cycle \" + str(no_rings_cycles + 1) + \" of \" + str(max_no_rings_cycles))\n            else:\n                # Perform next scan step (clockwise)\n                print(\"Scanning step \" + str(current_scan_step + 1) + \" - turning \" + str(SCAN_INCREMENT) + \" degrees clockwise\")\n                turn_by_angle(SCAN_INCREMENT, 20)  # Clockwise turn\n                wait(300, MSEC)  # Allow vision to stabilize\n            \n            continue\n        \n        # Found red rings! Reset counters and lock onto target\n        print(\"*** RED RINGS DETECTED! Locking onto target ***\")\n        no_rings_cycles = 0\n        current_scan_step = 0  # Reset scan since we found a target\n        \n        # Select the best target ring (largest/closest)\n        target_ring = max(red_rings, key=lambda x: x.width)\n        ring_width = target_ring.width\n        ring_center_x = target_ring.centerX\n        \n        print(\"Target red ring - Width: \" + str(ring_width) + \", Center: \" + str(ring_center_x))\n        \n        # Check for blue ring obstructions\n        obstruction, obstructing_blue = check_blue_obstruction(blue_rings, target_ring)\n        \n        if obstruction:\n            print(\"Blue ring obstruction detected - avoiding\")\n            avoid_blue_obstruction(obstructing_blue, target_ring)\n            continue\n        \n        # Perfect lock-on alignment\n        print(\"Achieving perfect lock-on alignment...\")\n        alignment_attempts = 0\n        max_alignment_attempts = 5\n        \n        while alignment_attempts < max_alignment_attempts:\n            # Get fresh vision data\n            _, fresh_red_rings = get_reliable_vision_data(1)\n            if not fresh_red_rings:\n                print(\"Lost target during alignment - resuming scan\")\n                break\n            \n            # Update target ring\n            target_ring = max(fresh_red_rings, key=lambda x: x.width)\n            \n            # Check if perfectly aligned\n            if align_to_ring(target_ring, FINE_ALIGNMENT_TOLERANCE):\n                print(\"*** PERFECT LOCK-ON ACHIEVED ***\")\n                break\n            \n            alignment_attempts += 1\n            print(\"Alignment attempt \" + str(alignment_attempts) + \"/\" + str(max_alignment_attempts))\n            wait(200, MSEC)\n        \n        if alignment_attempts >= max_alignment_attempts:\n            print(\"Max alignment attempts reached - continuing with current alignment\")\n        \n        # Determine approach strategy\n        strategy, move_distance, move_speed = get_approach_strategy(target_ring.width)\n        print(\"Strategy: \" + strategy + \", Distance: \" + str(int(move_distance)) + \" deg, Speed: \" + str(move_speed) + \"%\")\n        \n        if strategy == \"collect\":\n            print(\"*** COLLECTING RED RING ***\")\n            # Move forward to collect\n            drive_distance_with_timeout(SMALL_MOVE, 30, calculate_timeout(100, 30))\n            \n            if is_robot_stuck():\n                stuck_counter += 1\n                print(\"Robot stuck during collection, count: \" + str(stuck_counter))\n                if stuck_counter >= max_stuck_count:\n                    backup_from_obstacle()\n                    stuck_counter = 0\n                    continue\n            else:\n                stuck_counter = 0\n                rings_collected += 1\n                print(\"*** RED RING COLLECTED! Total: \" + str(rings_collected) + \" ***\")\n                \n                # Move forward after collection to clear the area\n                drive_distance_with_timeout(MEDIUM_MOVE, 35, calculate_timeout(150, 35))\n                \n                if is_robot_stuck():\n                    backup_from_obstacle()\n        \n        elif strategy == \"not_visible\":\n            print(\"Red ring too small/far - resuming 360-degree scan\")\n            # Continue scanning from where we left off\n            continue\n        \n        else:  # All approach strategies\n            print(\"Executing \" + strategy + \" - moving toward red target\")\n            success = drive_distance_with_timeout(move_distance, move_speed, \n                                                calculate_timeout(move_distance * 2, move_speed))\n            \n            if not success or is_robot_stuck():\n                stuck_counter += 1\n                print(\"Movement failed or robot stuck, count: \" + str(stuck_counter))\n                if stuck_counter >= max_stuck_count:\n                    backup_from_obstacle()\n                    stuck_counter = 0\n                    continue\n            else:\n                stuck_counter = 0\n\n        wait(100, MSEC)  # Small delay between cycles\n\n    print(\"\\n*** PROGRAM COMPLETED ***\")\n    print(\"Total red rings collected: \" + str(rings_collected))\n    \n    # Stop intake motors\n    intake_belt.stop()\n    intake_wheels.stop()\n    \n    print(\"Red ring collection program complete!\")\n\n# Initialize pistons and start main program\nmogoPiston1.set(True)\nmogoPiston2.set(True)\nmain()","textLanguage":"python","robotConfig":[],"slot":0,"platform":"V5","sdkVersion":"20240802.15.00.00","appVersion":"4.0.7","fileFormat":"2.0.0","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false}