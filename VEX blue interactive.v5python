{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\n# AI Classification Competition Element IDs\nclass GameElements:\n    MOBILE_GOAL = 0\n    RED_RING = 1\n    BLUE_RING = 2\n# AI Vision Color Descriptions\n# AI Vision Code Descriptions\nai_vision_12 = AiVision(Ports.PORT12, AiVision.ALL_AIOBJS)\nleft_motor_a = Motor(Ports.PORT3, GearSetting.RATIO_6_1, True)\nleft_motor_b = Motor(Ports.PORT8, GearSetting.RATIO_6_1, True)\nleft_motor_c = Motor(Ports.PORT10, GearSetting.RATIO_6_1, True)\nleft_drive_smart = MotorGroup(left_motor_a, left_motor_b, left_motor_c)\nright_motor_a = Motor(Ports.PORT4, GearSetting.RATIO_6_1, False)\nright_motor_b = Motor(Ports.PORT1, GearSetting.RATIO_6_1, False)\nright_motor_c = Motor(Ports.PORT12, GearSetting.RATIO_6_1, False)\nright_drive_smart = MotorGroup(right_motor_a, right_motor_b, right_motor_c)\ndrivetrain = DriveTrain(left_drive_smart, right_drive_smart, 219.44, 368.29999999999995, 304.79999999999995, MM, 0.4444444444444444)\ncontroller_1 = Controller(PRIMARY)\nIntakeBelt = Motor(Ports.PORT2, GearSetting.RATIO_6_1, False)\nIntakewheels = Motor(Ports.PORT13, GearSetting.RATIO_6_1,True )#initially 18\nMogoPiston1 = DigitalOut(brain.three_wire_port.c)\nMogotPiston2 = DigitalOut(brain.three_wire_port.d)\nCornerClear = DigitalOut(brain.three_wire_port.f)\nrotation_19LEFT = Rotation(Ports.PORT19, False)\nrotation_14RIGHT = Rotation(Ports.PORT14, False)\nintertial = Inertial(Ports.PORT20)\ngps_9 = Gps(Ports.PORT6, 101.60, -177.80, MM, 0)\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\n# Make random actually random\ndef initializeRandomSeed():\n    wait(100, MSEC)\n    random = brain.battery.voltage(MV) + brain.battery.current(CurrentUnits.AMP) * 100 + brain.timer.system_high_res()\n    urandom.seed(int(random))\n      \n# Set random seed \ninitializeRandomSeed()\n\n\ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(200, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n\n# define variables used for controlling motors based on controller inputs\ndrivetrain_l_needs_to_be_stopped_controller_1 = False\ndrivetrain_r_needs_to_be_stopped_controller_1 = False\n\n# define a task that will handle monitoring inputs from controller_1\ndef rc_auto_loop_function_controller_1():\n    global drivetrain_l_needs_to_be_stopped_controller_1, drivetrain_r_needs_to_be_stopped_controller_1, remote_control_code_enabled\n    # process the controller input every 20 milliseconds\n    # update the motors based on the input values\n    while True:\n        if remote_control_code_enabled:\n            \n            # calculate the drivetrain motor velocities from the controller joystick axies\n            # left = axis2 + axis4\n            # right = axis2 - axis4\n            drivetrain_left_side_speed = controller_1.axis2.position() + controller_1.axis4.position()\n            drivetrain_right_side_speed = controller_1.axis2.position() - controller_1.axis4.position()\n            \n            # check if the value is inside of the deadband range\n            if drivetrain_left_side_speed < 5 and drivetrain_left_side_speed > -5:\n                # check if the left motor has already been stopped\n                if drivetrain_l_needs_to_be_stopped_controller_1:\n                    # stop the left drive motor\n                    left_drive_smart.stop()\n                    # tell the code that the left motor has been stopped\n                    drivetrain_l_needs_to_be_stopped_controller_1 = False\n            else:\n                # reset the toggle so that the deadband code knows to stop the left motor next\n                # time the input is in the deadband range\n                drivetrain_l_needs_to_be_stopped_controller_1 = True\n            # check if the value is inside of the deadband range\n            if drivetrain_right_side_speed < 5 and drivetrain_right_side_speed > -5:\n                # check if the right motor has already been stopped\n                if drivetrain_r_needs_to_be_stopped_controller_1:\n                    # stop the right drive motor\n                    right_drive_smart.stop()\n                    # tell the code that the right motor has been stopped\n                    drivetrain_r_needs_to_be_stopped_controller_1 = False\n            else:\n                # reset the toggle so that the deadband code knows to stop the right motor next\n                # time the input is in the deadband range\n                drivetrain_r_needs_to_be_stopped_controller_1 = True\n            \n            # only tell the left drive motor to spin if the values are not in the deadband range\n            if drivetrain_l_needs_to_be_stopped_controller_1:\n                left_drive_smart.set_velocity(drivetrain_left_side_speed, PERCENT)\n                left_drive_smart.spin(FORWARD)\n            # only tell the right drive motor to spin if the values are not in the deadband range\n            if drivetrain_r_needs_to_be_stopped_controller_1:\n                right_drive_smart.set_velocity(drivetrain_right_side_speed, PERCENT)\n                right_drive_smart.spin(FORWARD)\n        # wait before repeating the process\n        wait(20, MSEC)\n\n# define variable for remote controller enable/disable\nremote_control_code_enabled = True\n\nrc_auto_loop_thread_controller_1 = Thread(rc_auto_loop_function_controller_1)\n\n#endregion VEXcode Generated Robot Configuration\n\n# Import required libraries\nimport math\n\n# Parameters for turning PID control - ADJUSTED VALUES\nturn_kP = 0.2     # Proportional constant - reduced from 0.3\nturn_kI = 0.0     # Integral constant\nturn_kD = 0.4     # Derivative constant - reduced from 0.69\nturn_tolerance = 1.0  # Acceptable error in degrees - increased from 0.5\nmin_turn_speed = 60  # Minimum turn speed to overcome friction\nmax_turn_speed = 75   # Maximum turn speed\n\ndef normalize_heading(heading):\n    \"\"\"Normalize heading to be between 0-360 degrees\"\"\"\n    while heading < 0:\n        heading += 360\n    while heading >= 360:\n        heading -= 360\n    return heading\n\ndef shortest_angle_difference(target, current):\n    \"\"\"Calculate the shortest angle to turn (handles wraparound)\"\"\"\n    diff = normalize_heading(target) - normalize_heading(current)\n    \n    # Handle cases where turning the other way is shorter\n    if diff > 180:\n        diff -= 360\n    elif diff < -180:\n        diff += 360\n        \n    return diff\n\ndef turn_to_heading(target_heading, max_speed):\n    \"\"\"\n    Turn the robot to a specific heading using PID control with GPS sensor\n    \n    Args:\n        target_heading: Target heading in degrees (0-360)\n        max_speed: Maximum turning speed (0-100)\n    \"\"\"\n    print(\"Starting turn to heading: \", target_heading, \" degrees\")\n    \n    # Normalize target heading to 0-360 range\n    target_heading = normalize_heading(target_heading)\n    \n    # PID variables\n    integral = 0\n    prev_error = 0\n    \n    # Initial error calculation\n    current_heading = gps_9.heading()\n    error = shortest_angle_difference(target_heading, current_heading)\n    \n    # Continue until we're close enough to the target\n    timer = Timer()  # Used to detect if we're stuck\n    timer.reset()\n    \n    # Add maximum time limit (3 seconds)\n    max_time = 3  # seconds\n    start_time = brain.timer.time(SECONDS)\n    \n    # Stall detection variables\n    stall_count = 0\n    max_stalls = 3\n    \n    while abs(error) > turn_tolerance:\n        # Check for timeout condition\n        if brain.timer.time(SECONDS) - start_time > max_time:\n            print(\"Turn timeout - breaking out of turn\")\n            break\n            \n        # Get current heading from GPS\n        current_heading = gps_9.heading()\n        \n        # Calculate error (how far we still need to turn)\n        error = shortest_angle_difference(target_heading, current_heading)\n        \n        # Calculate integral (sum of errors over time)\n        integral += error\n        \n        # Prevent integral windup\n        if abs(integral) > 1000:\n            integral = 1000 if integral > 0 else -1000\n        \n        # If we're not making progress, reset integral\n        if timer.time(SECONDS) > 1.5:  # Reduced from 2 seconds\n            if abs(prev_error - error) < 1:\n                integral = 0\n                print(\"Progress stalled, resetting integral\")\n                stall_count += 1\n                if stall_count >= max_stalls:\n                    print(\"Too many stalls, breaking out of turn\")\n                    break\n            timer.reset()\n        \n        # Calculate derivative (rate of change of error)\n        derivative = error - prev_error\n        \n        # Calculate motor power using PID\n        power = (error * turn_kP) + (integral * turn_kI) + (derivative * turn_kD)\n        \n        # Ensure minimum power to overcome friction\n        if 0 < abs(power) < min_turn_speed:\n            power = min_turn_speed * (1 if power > 0 else -1)\n        \n        # Limit power to specified maximum\n        if abs(power) > max_speed:\n            power = max_speed * (1 if power > 0 else -1)\n        \n        # Apply motor power for turning\n        # Positive error means we need to turn clockwise\n        left_drive_smart.spin(FORWARD, power, PERCENT)\n        right_drive_smart.spin(REVERSE, power, PERCENT)\n        \n        # Debug info\n        # print(\"Current: \", current_heading, \" Target: \", target_heading, \" Err: \", error, \" Power: \", power)\n        \n        # Update previous error for next iteration\n        prev_error = error\n        \n        # Short delay to prevent CPU hogging\n        wait(20, MSEC)\n    \n    # Stop the robot once target is reached\n    left_drive_smart.stop(BRAKE)\n    right_drive_smart.stop(BRAKE)\n    print(\"Turn complete: Current= \", gps_9.heading(), \" Target= \", target_heading)\n\ndef turn_by_angle(angle_degrees, max_speed):\n    \"\"\"\n    Turn the robot by a relative angle using the GPS sensor\n    \n    Args:\n        angle_degrees: Angle to turn in degrees (positive=clockwise, negative=counter-clockwise)\n        max_speed: Maximum turning speed (0-100)\n    \"\"\"\n    # Get current heading\n    current_heading = gps_9.heading()\n    \n    # Calculate target heading\n    target_heading = normalize_heading(current_heading + angle_degrees)\n    \n    print(\"Starting relative turn of \", angle_degrees, \" degrees\")\n    print(\"Current heading: \", current_heading, \" Target heading: \", target_heading)\n    \n    # Execute the turn\n    turn_to_heading(target_heading, max_speed)\n    \n    # Only try once more if significant error remains\n    current = gps_9.heading()\n    remaining_error = abs(shortest_angle_difference(target_heading, current))\n    if remaining_error > 5:  # Only retry if error is more than 5 degrees\n        print(\"Significant error remains (\", remaining_error, \"), attempting one more correction\")\n        wait(25, MSEC)\n        turn_to_heading(target_heading, max_speed)\n\n# PID constants for straight driving correction\nkP = -0.01  # Proportional gain\nkI = -0.02  # Integral gain\nkD = 0.0    # Derivative gain\n\n# Maximum allowed integral value to prevent wind-up\nMAX_INTEGRAL = 50\n\n# Function to reset rotation sensors\ndef reset_rotations():\n    rotation_19LEFT.reset_position()\n    rotation_14RIGHT.reset_position()\n    \n# Function to drive straight for a specific distance in degrees using PID\ndef drive_straight_pid(distance_deg, speed_pct):\n    # Reset rotation sensors\n    reset_rotations()\n    \n    # Target position and PID variables\n    target_position = abs(distance_deg)\n    direction = 1 if distance_deg > 0 else -1  # Determine direction\n    \n    # PID variables\n    prev_error = 0\n    integral = 0\n    \n    # Control loop variables\n    average_position = 0\n    last_time = brain.timer.time(MSEC)\n    \n    # Add timeout to prevent infinite loop\n    max_time = 5  # seconds (adjust as needed)\n    start_time = brain.timer.time(SECONDS)\n    \n    # Loop until we reach the target distance\n    while average_position < target_position:\n        # Check for timeout\n        if brain.timer.time(SECONDS) - start_time > max_time:\n            print(\"Drive timeout - breaking out\")\n            break\n            \n        # Calculate time delta for derivative calculation\n        current_time = brain.timer.time(MSEC)\n        dt = current_time - last_time\n        dt = max(dt, 1)  # Prevent division by zero\n        last_time = current_time\n        \n        left_position = abs(rotation_19LEFT.position(DEGREES))\n        right_position = abs(rotation_14RIGHT.position(DEGREES))\n        \n        average_position = (left_position + right_position) / 2\n        position_error = left_position - right_position\n        \n        p_term = position_error * kP\n        \n        integral += position_error * dt / 1000.0\n        integral = max(min(integral, MAX_INTEGRAL), -MAX_INTEGRAL)  # Clamp to prevent windup\n        i_term = integral * kI\n        \n        derivative = (position_error - prev_error) / (dt / 1000.0)\n        d_term = derivative * kD\n        \n        correction = p_term + i_term + d_term\n        \n        # Store error for next iteration\n        prev_error = position_error\n        \n        # Apply the correction to the motors\n        left_speed = speed_pct * direction + correction\n        right_speed = speed_pct * direction - correction\n        \n        # Constrain speeds to valid range (-100 to 100)\n        left_speed = max(min(left_speed, 100), -100)\n        right_speed = max(min(right_speed, 100), -100)\n        \n        # Set motor speeds\n        left_drive_smart.set_velocity(left_speed, PERCENT)\n        right_drive_smart.set_velocity(right_speed, PERCENT)\n        left_drive_smart.spin(FORWARD)\n        right_drive_smart.spin(FORWARD)\n        \n        # Small delay to avoid hogging CPU\n        wait(20, MSEC)\n        \n        # Display debug information\n        print(\"L: \", left_position, \" R: \", right_position, \" E: \", position_error, \" P: \", (average_position/target_position*100))\n        print(\"P: \", p_term, \" I: \", i_term, \" D: \", d_term, \"\\n\")\n        \n    # Stop all motors\n    left_drive_smart.stop(BRAKE)\n    right_drive_smart.stop(BRAKE)\n    \n    print(\"Drive complete!\")\n    \n    return True###\n\n# Function to aim for a specific distance and handle timeouts\ndef drive_distance_with_timeout(distance_deg, speed_pct, timeout_sec):\n     # Wait for rotation sensors to initialize\n    wait(100, MSEC)\n\n    # Start timer\n    timer = Timer()\n    \n    # Execute drive function with timeout\n    success = drive_straight_pid(distance_deg, speed_pct)\n    \n    # Check if timeout occurred\n    if timer.time(SECONDS) >= timeout_sec:\n        print(\"Drive timed out!\")\n        print(\"Drive complete!\")\n        \n        # Stop all motors\n        left_drive_smart.stop(BRAKE)\n        right_drive_smart.stop(BRAKE)\n        return False\n    \n    return success\n\n# Function to calculate the time needed to cover a certain distance at a given speed\ndef calculate_timeout(distance_mm, speed_percent):\n    # Convert speed percentage to actual velocity (mm/s)\n    # Assuming 100% speed is approximately 500 mm/s (adjust this based on your robot's specs)\n    max_speed = 500  # mm/s at 100% speed\n    actual_speed = (speed_percent / 100) * max_speed  # mm/s\n    \n    # Calculate time needed (with a safety factor of 1.5)\n    timeout = (distance_mm / actual_speed) * 1.5  # seconds\n    \n    # Ensure minimum timeout\n    return max(timeout, 1.0)  # At least 1 second timeout\n\n# Function to perform a backup maneuver when stuck\ndef backup_from_obstacle():\n    print(\"Initiating backup maneuver\")\n    \n    # Store current position to detect movement\n    start_left_pos = rotation_19LEFT.position(DEGREES)\n    start_right_pos = rotation_14RIGHT.position(DEGREES)\n    \n    # Backup with medium speed\n    left_drive_smart.spin(REVERSE, 40, PERCENT)\n    right_drive_smart.spin(REVERSE, 40, PERCENT)\n    \n    # Backup for a short time\n    wait(1000, MSEC)\n    \n    # Stop motors\n    left_drive_smart.stop(BRAKE)\n    right_drive_smart.stop(BRAKE)\n    \n    # Turn slightly to change direction\n    random_turn = 45  # Random turn angle between 30 and 60 degrees\n    turn_by_angle(random_turn, 30)\n    \n    print(\"Backup complete\")\n\n# Function to detect if robot is stuck\ndef is_robot_stuck():\n    # Store initial position\n    initial_left_pos = rotation_19LEFT.position(DEGREES)\n    initial_right_pos = rotation_14RIGHT.position(DEGREES)\n    \n    # Wait a short time while motors should be moving\n    wait(500, MSEC)\n    \n    # Check if position has changed significantly\n    current_left_pos = rotation_19LEFT.position(DEGREES)\n    current_right_pos = rotation_14RIGHT.position(DEGREES)\n    \n    left_change = abs(current_left_pos - initial_left_pos)\n    right_change = abs(current_right_pos - initial_right_pos)\n    \n    # If wheels are spinning but we're not moving much, we're stuck\n    if (left_change < 5) and (right_change < 5):\n        return True\n    \n    return False\n\ndrivetrain.set_turn_velocity(30, PERCENT)\ndrivetrain.set_drive_velocity(30, PERCENT)\n\nwheelDiameter = 2.75  # Inches\nwheelCircumference = math.pi * wheelDiameter\ntravelDistance = 48  # Inches\nerror = 5  # inches\n\nid_to_name = {\n    0: \"Mobile Goal\",\n    1: \"Red Ring\",\n    2: \"Blue Ring\"\n}\n\ntravelDistance -= error\n\nnumberOfDegrees = (travelDistance/wheelCircumference) * 360\nspeed = 100  # 75\n\nturnAngle = 90  # turn angle needs to be changed depending on the iteration.\n\n# Distance to travel after intake before stopping to scan again (in mm)\npost_intake_travel_distance = 200  # Adjust this based on your robot's needs\npost_intake_speed = 30  # Speed percentage for post-intake movement\n\n# Scanning speed parameters\nscanning_speed = 15  # Regular scanning speed when looking for blue rings - reverted to 15% like in original code\n\ndef main():\n    print(\"Starting blue ring detection and navigation program\")\n    rings_collected = 0\n    stuck_counter = 0  # Counter to track consecutive stuck detections\n    max_stuck_count = 3  # Max number of consecutive stuck detections before emergency maneuver\n\n    wait(1, SECONDS)\n    print(\"Scanning for blue rings...\")\n   \n    # Initialize intake motors - keep them running during operation\n    IntakeBelt.spin(FORWARD, 85, PERCENT)\n    intake_speed = 85  # Store intake speed for control\n    Intakewheels.spin(FORWARD, intake_speed, PERCENT)\n\n    while True:\n        print(\"Starting scan cycle. Blue rings collected so far:\", rings_collected)\n        print(\"Battery voltage:\", brain.battery.voltage(VOLT), \"V\")  # Debug: Monitor battery\n        print(\"GPS heading:\", gps_9.heading(), \"degrees\")  # Debug: Monitor GPS\n        \n        objs = ai_vision_12.take_snapshot(AiVision.ALL_AIOBJS)\n\n        # Check if we found any objects on the field\n        if objs:\n            # Filter for blue rings only\n            blue_rings = [obj for obj in objs if obj.id == GameElements.BLUE_RING]\n            red_rings = [obj for obj in objs if obj.id == GameElements.RED_RING]\n\n            # If no blue rings detected, rotate to scan\n            if not blue_rings:\n                print(\"No blue rings detected, scanning by rotating...\")\n                drivetrain.stop()\n                left_drive_smart.spin(REVERSE, scanning_speed, PERCENT)\n                right_drive_smart.spin(FORWARD, scanning_speed, PERCENT)\n                wait(500, MSEC)  # Rotate for 0.5 seconds\n                left_drive_smart.stop()\n                right_drive_smart.stop()\n                wait(200, MSEC)\n                continue\n\n            # Find the nearest blue ring (largest apparent width)\n            nearest_blue_ring = blue_rings[0]\n            max_blue_width = nearest_blue_ring.width\n            for ring in blue_rings:\n                if ring.width > max_blue_width:\n                    max_blue_width = ring.width\n                    nearest_blue_ring = ring\n\n            blue_ring_center_x = nearest_blue_ring.centerX\n            blue_ring_width = nearest_blue_ring.width\n            error = blue_ring_center_x - 160  # Center of vision sensor (assuming 320px width)\n\n            print(\"Detected Blue Ring, width: {}, center_x: {}, error: {}\".format(\n                blue_ring_width, blue_ring_center_x, error))\n\n            # Check for red ring obstruction (nearest red ring closer than blue ring)\n            red_obstruction = False\n            if red_rings:\n                nearest_red_ring = red_rings[0]\n                max_red_width = nearest_red_ring.width\n                for ring in red_rings:\n                    if ring.width > max_red_width:\n                        max_red_width = ring.width\n                        nearest_red_ring = ring\n\n                # If red ring is closer (larger width) and in front of blue ring\n                if max_red_width > blue_ring_width and abs(nearest_red_ring.centerX - 160) < 50:\n                    red_obstruction = True\n                    print(\"Red ring obstruction detected, width: {}, center_x: {}\".format(\n                        max_red_width, nearest_red_ring.centerX))\n\n            if red_obstruction:\n                print(\"Maneuvering around red ring...\")\n                # Pause intake to prevent accidental red ring intake\n                IntakeBelt.stop()\n                Intakewheels.stop()\n\n                # Determine direction to avoid red ring (based on its position)\n                red_error = nearest_red_ring.centerX - 160\n                avoid_angle = 45 if red_error > 0 else -45  # Turn away from red ring\n                turn_by_angle(avoid_angle, 30)  # Use your PID turn function\n                drivetrain.drive_for(FORWARD, 150, MM)  # Move forward to clear\n                turn_by_angle(-avoid_angle, 30)  # Turn back toward original direction\n\n                # Resume intake\n                IntakeBelt.spin(FORWARD, intake_speed, PERCENT)\n                Intakewheels.spin(FORWARD, intake_speed, PERCENT)\n                wait(200, MSEC)\n                continue  # Re-scan after maneuver\n\n            # No red ring obstruction, proceed to blue ring\n            if blue_ring_width > 100:  # Blue ring is close enough\n                print(\"Blue ring in range - driving forward to collect\")\n                drivetrain.drive_for(FORWARD, 150, MM)\n                \n                # Check if stuck while driving to ring\n                if is_robot_stuck():\n                    stuck_counter += 1\n                    print(\"Detected potential obstacle, stuck counter:\", stuck_counter)\n                    if stuck_counter >= max_stuck_count:\n                        backup_from_obstacle()\n                        stuck_counter = 0\n                        continue\n                else:\n                    stuck_counter = 0  # Reset counter if we're moving\n                    \n                wait(500, MSEC)  # Ensure ring collection\n                rings_collected += 1\n                print(\"Blue ring collected! Total rings:\", rings_collected)\n\n                # Move forward to clear intake area\n                print(\"Moving forward to clear intake area...\")\n                drivetrain.drive_for(FORWARD, 200, MM)\n                \n                # Check if stuck after ring collection\n                if is_robot_stuck():\n                    backup_from_obstacle()\n                \n                drivetrain.stop()\n                wait(200, MSEC)\n\n            elif error < -20:  # Blue ring is to the left\n                print(\"Blue ring offset to LEFT - adjusting\")\n                left_drive_smart.stop()\n                right_drive_smart.spin(FORWARD, 15, PERCENT)\n                wait(100, MSEC)\n                right_drive_smart.stop()\n                drivetrain.drive_for(FORWARD, 80, MM)\n                \n                # Check if stuck while moving\n                if is_robot_stuck():\n                    backup_from_obstacle()\n\n            elif error > 20:  # Blue ring is to the right\n                print(\"Blue ring offset to RIGHT - adjusting\")\n                right_drive_smart.stop()\n                left_drive_smart.spin(FORWARD, 15, PERCENT)\n                wait(100, MSEC)\n                left_drive_smart.stop()\n                drivetrain.drive_for(FORWARD, 80, MM)\n                \n                # Check if stuck while moving\n                if is_robot_stuck():\n                    backup_from_obstacle()\n\n            else:  # Blue ring is centered but not close enough\n                print(\"Blue ring centered but not close - driving forward\")\n                drivetrain.drive_for(FORWARD, 100, MM)\n                \n                # Check if stuck while moving\n                if is_robot_stuck():\n                    backup_from_obstacle()\n\n        else:\n            # No objects detected, stop and scan\n            print(\"No objects detected. Scanning...\")\n            drivetrain.stop()\n            left_drive_smart.spin(REVERSE, scanning_speed, PERCENT)\n            right_drive_smart.spin(FORWARD, scanning_speed, PERCENT)\n            wait(500, MSEC)\n            left_drive_smart.stop()\n            right_drive_smart.stop()\n            wait(200, MSEC)\n\n    print(\"Navigation complete.\")\n\nmain()","textLanguage":"python","robotConfig":[],"slot":0,"platform":"V5","sdkVersion":"20240802.15.00.00","appVersion":"4.0.7","fileFormat":"2.0.0","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false}