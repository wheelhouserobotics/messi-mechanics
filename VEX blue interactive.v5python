{"mode":"Text","hardwareTarget":"brain","textContent":"from vex import *\nimport urandom\nimport math\n\n# Brain should be defined by default\nbrain = Brain()\n\n# Robot configuration code\n# AI Classification Competition Element IDs\nclass GameElements:\n    MOBILE_GOAL = 0\n    RED_RING = 1\n    BLUE_RING = 2\n\n# Motor configuration\nleft_motor_a = Motor(Ports.PORT20, GearSetting.RATIO_18_1, True)\nleft_motor_b = Motor(Ports.PORT11, GearSetting.RATIO_18_1, True)\nleft_drive_smart = MotorGroup(left_motor_a, left_motor_b)\nright_motor_a = Motor(Ports.PORT12, GearSetting.RATIO_18_1, False)\nright_motor_b = Motor(Ports.PORT16, GearSetting.RATIO_18_1, False)\nright_drive_smart = MotorGroup(right_motor_a, right_motor_b)\ndrivetrain = DriveTrain(left_drive_smart, right_drive_smart, 219.44, 295, 40, MM, 1)\n\n# Pneumatic configuration\nleft_piston = DigitalOut(brain.three_wire_port.a)  # For mobile goal or mechanism\nright_piston = DigitalOut(brain.three_wire_port.b)  # For mobile goal or mechanism\nextent_piston = DigitalOut(brain.three_wire_port.cn  )  # For additional mechanism\n\n# Controller\ncontroller_1 = Controller(PRIMARY)\n\n# Intake motors\nintake_belt = Motor(Ports.PORT17, GearSetting.RATIO_6_1, True)\nintake_wheels = Motor(Ports.PORT18, GearSetting.RATIO_6_1, False)\n\n# Sensors\ngps_sensor = Gps(Ports.PORT21, 132.08, -88.90, MM, 0)\nai_vision_sensor = AiVision(Ports.PORT2, AiVision.ALL_AIOBJS)\nleft_rotation = Rotation(Ports.PORT14, False)\nright_rotation = Rotation(Ports.PORT3, False)\n\n# Wait for sensors to initialize\nwait(30, MSEC)\n\n# Make random actually random\ndef initializeRandomSeed():\n    wait(100, MSEC)\n    random = brain.battery.voltage(MV) + brain.battery.current(CurrentUnits.AMP) * 100 + brain.timer.system_high_res()\n    urandom.seed(int(random))\n\n# Set random seed\ninitializeRandomSeed()\n\n# Helper function to play sounds\ndef play_vexcode_sound(sound_name):\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# Clear console\nwait(200, MSEC)\nprint(\"\\033[2J\")\n\n# Teleop control thread\ndrivetrain_needs_to_be_stopped_controller_1 = False\nremote_control_code_enabled = True\n\ndef rc_auto_loop_function_controller_1():\n    global drivetrain_needs_to_be_stopped_controller_1, remote_control_code_enabled\n    while True:\n        if remote_control_code_enabled:\n            drivetrain_left_side_speed = controller_1.axis2.position() + controller_1.axis1.position()\n            drivetrain_right_side_speed = controller_1.axis2.position() - controller_1.axis1.position()\n            if abs(drivetrain_left_side_speed) < 5 and abs(drivetrain_right_side_speed) < 5:\n                if drivetrain_needs_to_be_stopped_controller_1:\n                    left_drive_smart.stop()\n                    right_drive_smart.stop()\n                    drivetrain_needs_to_be_stopped_controller_1 = False\n            else:\n                drivetrain_needs_to_be_stopped_controller_1 = True\n                left_drive_smart.set_velocity(drivetrain_left_side_speed, PERCENT)\n                right_drive_smart.set_velocity(drivetrain_right_side_speed, PERCENT)\n                left_drive_smart.spin(FORWARD)\n                right_drive_smart.spin(FORWARD)\n        wait(20, MSEC)\n\nrc_auto_loop_thread_controller_1 = Thread(rc_auto_loop_function_controller_1)\n\n# Parameters for turning PID control\nturn_kP = 0.35    # Proportional constant\nturn_kI = 0.001   # Integral constant\nturn_kD = 0.03    # Derivative constant\nturn_tolerance = 1.0  # Acceptable error in degrees\nmin_turn_speed = 10  # Minimum turn speed to overcome friction\nmax_turn_speed = 30  # Maximum turn speed\n\ndef normalize_heading(heading):\n    \"\"\"Normalize heading to be between 0-360 degrees\"\"\"\n    while heading < 0:\n        heading += 360\n    while heading >= 360:\n        heading -= 360\n    return heading\n\ndef shortest_angle_difference(target, current):\n    \"\"\"Calculate the shortest angle to turn (handles wraparound)\"\"\"\n    diff = normalize_heading(target) - normalize_heading(current)\n    if diff > 180:\n        diff -= 360\n    elif diff < -180:\n        diff += 360\n    return diff\n\ndef turn_to_heading(target_heading, max_speed):\n    \"\"\"Turn the robot to a specific heading using PID control with GPS sensor\"\"\"\n    if not gps_sensor.installed():\n        print(\"Error: GPS sensor not detected\")\n        return False\n\n    print(f\"Starting turn to heading: {target_heading} degrees\")\n    target_heading = normalize_heading(target_heading)\n    integral = 0\n    prev_error = 0\n    current_heading = gps_sensor.heading()\n    error = shortest_angle_difference(target_heading, current_heading)\n    timer = Timer()\n    timer.reset()\n    max_time = 3  # seconds\n    start_time = brain.timer.time(SECONDS)\n    stall_count = 0\n    max_stalls = 3\n\n    while abs(error) > turn_tolerance:\n        if brain.timer.time(SECONDS) - start_time > max_time:\n            print(\"Turn timeout - breaking out of turn\")\n            break\n\n        current_heading = gps_sensor.heading()\n        error = shortest_angle_difference(target_heading, current_heading)\n        integral += error\n        if abs(integral) > 1000:\n            integral = 1000 if integral > 0 else -1000\n\n        if timer.time(SECONDS) > 1.5:\n            if abs(prev_error - error) < 1:\n                integral = 0\n                print(\"Progress stalled, resetting integral\")\n                stall_count += 1\n                if stall_count >= max_stalls:\n                    print(\"Too many stalls, breaking out of turn\")\n                    break\n            timer.reset()\n\n        derivative = error - prev_error\n        power = (error * turn_kP) + (integral * turn_kI) + (derivative * turn_kD)\n        if 0 < abs(power) < min_turn_speed:\n            power = min_turn_speed * (1 if power > 0 else -1)\n        if abs(power) > max_speed:\n            power = max_speed * (1 if power > 0 else -1)\n\n        left_drive_smart.spin(FORWARD, power, PERCENT)\n        right_drive_smart.spin(REVERSE, power, PERCENT)\n        prev_error = error\n        wait(20, MSEC)\n\n    left_drive_smart.stop(BRAKE)\n    right_drive_smart.stop(BRAKE)\n    print(f\"Turn complete: Current= {gps_sensor.heading():.1f}, Target= {target_heading}\")\n    return True\n\ndef turn_by_angle(angle_degrees, max_speed):\n    \"\"\"Turn the robot by a relative angle using the GPS sensor\"\"\"\n    if not gps_sensor.installed():\n        print(\"Error: GPS sensor not detected\")\n        return False\n\n    current_heading = gps_sensor.heading()\n    target_heading = normalize_heading(current_heading + angle_degrees)\n    print(f\"Starting relative turn of {angle_degrees} degrees\")\n    print(f\"Current heading: {current_heading:.1f}, Target heading: {target_heading:.1f}\")\n    turn_to_heading(target_heading, max_speed)\n\n    current = gps_sensor.heading()\n    remaining_error = abs(shortest_angle_difference(target_heading, current))\n    if remaining_error > 5:\n        print(f\"Significant error remains ({remaining_error:.1f}), attempting one more correction\")\n        wait(25, MSEC)\n        turn_to_heading(target_heading, max_speed)\n    return True\n\n# PID constants for straight driving\nkP = 0.3   # Proportional gain\nkI = 0.05  # Integral gain\nkD = 0.02  # Derivative gain\nMAX_INTEGRAL = 50\n\ndef reset_rotations():\n    \"\"\"Reset rotation sensors\"\"\"\n    if not (left_rotation.installed() and right_rotation.installed()):\n        print(\"Error: Rotation sensors not detected\")\n        return False\n    left_rotation.reset_position()\n    right_rotation.reset_position()\n    return True\n\ndef drive_straight_pid(distance_deg, speed_pct):\n    \"\"\"Drive straight for a specific distance in degrees using PID\"\"\"\n    if not reset_rotations():\n        return False\n\n    target_position = abs(distance_deg)\n    direction = 1 if distance_deg > 0 else -1\n    prev_error = 0\n    integral = 0\n    average_position = 0\n    last_time = brain.timer.time(MSEC)\n    max_time = 5\n    start_time = brain.timer.time(SECONDS)\n\n    while average_position < target_position:\n        if brain.timer.time(SECONDS) - start_time > max_time:\n            print(\"Drive timeout - breaking out\")\n            break\n\n        current_time = brain.timer.time(MSEC)\n        dt = max(current_time - last_time, 1)\n        last_time = current_time\n\n        left_position = abs(left_rotation.position(DEGREES))\n        right_position = abs(right_rotation.position(DEGREES))\n        average_position = (left_position + right_position) / 2\n        position_error = left_position - right_position\n\n        p_term = position_error * kP\n        integral += position_error * dt / 1000.0\n        integral = max(min(integral, MAX_INTEGRAL), -MAX_INTEGRAL)\n        i_term = integral * kI\n        derivative = (position_error - prev_error) / (dt / 1000.0)\n        d_term = derivative * kD\n        correction = p_term + i_term + d_term\n\n        prev_error = position_error\n        left_speed = speed_pct * direction + correction\n        right_speed = speed_pct * direction - correction\n        left_speed = max(min(left_speed, 100), -100)\n        right_speed = max(min(right_speed, 100), -100)\n\n        left_drive_smart.set_velocity(left_speed, PERCENT)\n        right_drive_smart.set_velocity(right_speed, PERCENT)\n        left_drive_smart.spin(FORWARD)\n        right_drive_smart.spin(FORWARD)\n\n        print(f\"L: {left_position:.1f} R: {right_position:.1f} E: {position_error:.1f} P: {(average_position/target_position*100):.1f}%\")\n        wait(20, MSEC)\n\n    left_drive_smart.stop(BRAKE)\n    right_drive_smart.stop(BRAKE)\n    right_drive_smart.stop(BRAKE)\n    print(\"Drive complete!\")\n    return True\n\ndef drive_distance_with_timeout(distance_deg, speed_pct, timeout_sec):\n    \"\"\"Drive with timeout handling\"\"\"\n    wait(100, MSEC)\n    timer = Timer()\n    timer.reset()\n    success = drive_straight_pid(distance_deg, speed_pct)\n    if timer.time(SECONDS) >= timeout_sec:\n        print(\"Drive timed out!\")\n        left_drive_smart.stop(BRAKE)\n        right_drive_smart.stop(BRAKE)\n        return False\n    return success\n\ndef calculate_timeout(distance_mm, speed_percent):\n    \"\"\"Calculate timeout based on distance and speed\"\"\"\n    max_speed = 500  # mm/s at 100% speed (adjust based on robot testing)\n    actual_speed = (speed_percent / 100) * max_speed\n    timeout = (distance_mm / actual_speed) * 1.5\n    return max(timeout, 1.0)\n\ndef backup_from_obstacle():\n    \"\"\"Perform backup maneuver when stuck\"\"\"\n    print(\"Initiating backup maneuver\")\n    start_left_pos = left_rotation.position(DEGREES)\n    start_right_pos = right_rotation.position(DEGREES)\n    left_drive_smart.spin(REVERSE, 40, PERCENT)\n    right_drive_smart.spin(REVERSE, 40, PERCENT)\n    wait(1000, MSEC)\n    left_drive_smart.stop(BRAKE)\n    right_drive_smart.stop(BRAKE)\n    random_turn = 45\n    turn_by_angle(random_turn, 30)\n    print(\"Backup complete\")\n\ndef is_robot_stuck():\n    \"\"\"Detect if robot is stuck\"\"\"\n    initial_left_pos = left_rotation.position(DEGREES)\n    initial_right_pos = right_rotation.position(DEGREES)\n    wait(500, MSEC)\n    current_left_pos = left_rotation.position(DEGREES)\n    current_right_pos = right_rotation.position(DEGREES)\n    left_change = abs(current_left_pos - initial_left_pos)\n    right_change = abs(current_right_pos - initial_right_pos)\n    return left_change < 10 and right_change < 10  # Increased threshold\n\n# Constants for navigation\nwheelDiameter = 2.75  # Inches\nwheelCircumference = math.pi * wheelDiameter\ntravelDistance = 48  # Inches\nerror = 5  # Inches\nnumberOfDegrees = ((travelDistance - error) / wheelCircumference) * 360\nspeed = 75  # Percent\nscanning_speed = 15  # Percent\npost_intake_travel_distance = 200  # mm\npost_intake_speed = 30  # Percent\n\nid_to_name = {\n    0: \"Mobile Goal\",\n    1: \"Red Ring\",\n    2: \"Blue Ring\"\n}\n\ndef main():\n    \"\"\"Main program for blue ring detection and navigation\"\"\"\n    if not gps_sensor.installed():\n        print(\"Error: GPS sensor not detected\")\n        return\n    if not ai_vision_sensor.installed():\n        print(\"Error: AI Vision sensor not detected\")\n        return\n    if not (left_rotation.installed() and right_rotation.installed()):\n        print(\"Error: Rotation sensors not detected\")\n        return\n\n    print(\"Starting blue ring detection and navigation program\")\n    rings_collected = 0\n    stuck_counter = 0\n    max_stuck_count = 3\n    max_rings = 5  # Exit condition\n\n    intake_belt.spin(FORWARD, 85, PERCENT)\n    intake_wheels.spin(FORWARD, 85, PERCENT)\n    intake_speed = 85\n\n    drivetrain.set_turn_velocity(30, PERCENT)\n    drivetrain.set_drive_velocity(30, PERCENT)\n\n    while rings_collected < max_rings:\n        print(f\"Starting scan cycle. Blue rings collected: {rings_collected}\")\n        print(f\"GPS heading: {gps_sensor.heading():.1f} degrees\")\n        print(f\"Battery voltage: {brain.battery.voltage(VOLT)} V\")\n \n        remote_control_code_enabled = False  # Disable teleop\n\n        objs = ai_vision_sensor.take_snapshot(AiVision.ALL_AIOBJS)\n\n        if objs:\n            blue_rings = [obj for obj in objs if obj.id == GameElements.BLUE_RING]\n            red_rings = [obj for obj in objs if obj.id == GameElements.RED_RING]\n\n            if not blue_rings:\n                print(\"No blue rings detected, scanning by rotating...\")\n                left_drive_smart.spin(REVERSE, scanning_speed, PERCENT)\n                right_drive_smart.spin(FORWARD, scanning_speed, PERCENT)\n                wait(500, MSEC)\n                left_drive_smart.stop()\n                right_drive_smart.stop()\n                wait(200, MSEC)\n                continue\n\n            nearest_blue_ring = max(blue_rings, key=lambda x: x.width)\n            blue_ring_center_x = nearest_blue_ring.centerX\n            blue_ring_width = nearest_blue_ring.width\n            error = blue_ring_center_x - 160  # Center of 320px vision sensor\n\n            print(f\"Detected Blue Ring, width: {blue_ring_width}, center_x: {blue_ring_center_x}, error: {error}\")\n\n            red_obstruction = False\n            if red_rings:\n                nearest_red_ring = max(red_rings, key=lambda x: x.width)\n                if nearest_red_ring.width > blue_ring_width and abs(nearest_red_ring.centerX - 160) < 50:\n                    red_obstruction = True\n                    print(f\"Red ring obstruction detected, width: {nearest_red_ring.width}, center_x: {nearest_red_ring.centerX}\")\n\n            if red_obstruction:\n                print(\"Maneuvering around red ring...\")\n                intake_belt.stop()\n                intake_wheels.stop()\n                red_error = nearest_red_ring.centerX - 160\n                avoid_angle = 45 if red_error > 0 else -45\n                turn_by_angle(avoid_angle, 30)\n                drive_distance_with_timeout(numberOfDegrees, 30, calculate_timeout(150, 30))\n                turn_by_angle(-avoid_angle, 30)\n                intake_belt.spin(FORWARD, intake_speed, PERCENT)\n                intake_wheels.spin(FORWARD, intake_speed, PERCENT)\n                wait(200, MSEC)\n                continue\n\n            if blue_ring_width > 100:\n                print(\"Blue ring in range - driving to collect\")\n                drive_distance_with_timeout(numberOfDegrees, 30, calculate_timeout(150, 30))\n                if is_robot_stuck():\n                    stuck_counter += 1\n                    print(f\"Detected potential obstacle, stuck counter: {stuck_counter}\")\n                    if stuck_counter >= max_stuck_count:\n                        backup_from_obstacle()\n                        stuck_counter = 0\n                        continue\n                else:\n                    stuck_counter = 0\n                wait(500, MSEC)\n                rings_collected += 1\n                print(f\"Blue ring collected! Total rings: {rings_collected}\")\n                drive_distance_with_timeout(numberOfDegrees, post_intake_speed, calculate_timeout(post_intake_travel_distance, post_intake_speed))\n                if is_robot_stuck():\n                    backup_from_obstacle()\n                wait(200, MSEC)\n\n            elif error < -20:\n                print(\"Blue ring offset to LEFT - adjusting\")\n                turn_by_angle(-15, 15)\n                drive_distance_with_timeout(numberOfDegrees / 2, 30, calculate_timeout(80, 30))\n                if is_robot_stuck():\n                    backup_from_obstacle()\n\n            elif error > 20:\n                print(\"Blue ring offset to RIGHT - adjusting\")\n                turn_by_angle(15, 15)\n                drive_distance_with_timeout(numberOfDegrees / 2, 30, calculate_timeout(80, 30))\n                if is_robot_stuck():\n                    backup_from_obstacle()\n\n            else:\n                print(\"Blue ring centered but not close - driving forward\")\n                drive_distance_with_timeout(numberOfDegrees, 30, calculate_timeout(100, 30))\n                if is_robot_stuck():\n                    backup_from_obstacle()\n\n        else:\n            print(\"No objects detected. Scanning...\")\n            left_drive_smart.spin(REVERSE, scanning_speed, PERCENT)\n            right_drive_smart.spin(FORWARD, scanning_speed, PERCENT)\n            wait(500, MSEC)\n            left_drive_smart.stop()\n            right_drive_smart.stop()\n            wait(200, MSEC)\n\n    print(\"Navigation complete. Total blue rings collected:\", rings_collected)\n    intake_belt.stop()\n    intake_wheels.stop()\n    remote_control_code_enabled = True  # Re-enable teleop\n\n# Start the program\nmain()","textLanguage":"python","robotConfig":[],"slot":0,"platform":"V5","sdkVersion":"20240802.15.00.00","appVersion":"4.0.7","fileFormat":"2.0.0","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false}