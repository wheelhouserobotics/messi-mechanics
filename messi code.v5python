{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\n# AI Classification Competition Element IDs\nclass GameElements:\n    MOBILE_GOAL = 0\n    RED_RING = 1\n    BLUE_RING = 2\n# AI Vision Color Descriptions\n# AI Vision Code Descriptions\nai_vision_12 = AiVision(Ports.PORT12, AiVision.ALL_AIOBJS)\nleft_motor_a = Motor(Ports.PORT3, GearSetting.RATIO_6_1, True)\nleft_motor_b = Motor(Ports.PORT8, GearSetting.RATIO_6_1, True)\nleft_drive_smart = MotorGroup(left_motor_a, left_motor_b)\nright_motor_a = Motor(Ports.PORT4, GearSetting.RATIO_6_1, False)\nright_motor_b = Motor(Ports.PORT1, GearSetting.RATIO_6_1, False)\nright_drive_smart = MotorGroup(right_motor_a, right_motor_b)\ndrivetrain = DriveTrain(left_drive_smart, right_drive_smart, 219.44, 368.29999999999995, 304.79999999999995, MM, 0.4444444444444444)\ncontroller_1 = Controller(PRIMARY)\nIntakeBelt = Motor(Ports.PORT2, GearSetting.RATIO_6_1, False)\nIntakewheels = Motor(Ports.PORT18, GearSetting.RATIO_6_1, True)\nMogoPiston1 = DigitalOut(brain.three_wire_port.c)\nMogotPiston2 = DigitalOut(brain.three_wire_port.d)\nCornerClear = DigitalOut(brain.three_wire_port.f)\nOdomLEFT = Rotation(Ports.PORT19, False)\nodomRIGHT = Rotation(Ports.PORT14, False)\nintertial = Inertial(Ports.PORT20)\ngps_6 = Gps(Ports.PORT6, 101.60, -177.80, MM, 0)\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\n# Make random actually random\ndef initializeRandomSeed():\n    wait(100, MSEC)\n    random = brain.battery.voltage(MV) + brain.battery.current(CurrentUnits.AMP) * 100 + brain.timer.system_high_res()\n    urandom.seed(int(random))\n      \n# Set random seed \ninitializeRandomSeed()\n\n\ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(200, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n\n\n\n# define variables used for controlling motors based on controller inputs\ndrivetrain_l_needs_to_be_stopped_controller_1 = False\ndrivetrain_r_needs_to_be_stopped_controller_1 = False\n\n# define a task that will handle monitoring inputs from controller_1\ndef rc_auto_loop_function_controller_1():\n    global drivetrain_l_needs_to_be_stopped_controller_1, drivetrain_r_needs_to_be_stopped_controller_1, remote_control_code_enabled\n    # process the controller input every 20 milliseconds\n    # update the motors based on the input values\n    while True:\n        if remote_control_code_enabled:\n            \n            # calculate the drivetrain motor velocities from the controller joystick axies\n            # left = axis2 + axis4\n            # right = axis2 - axis4\n            drivetrain_left_side_speed = controller_1.axis2.position() + controller_1.axis4.position()\n            drivetrain_right_side_speed = controller_1.axis2.position() - controller_1.axis4.position()\n            \n            # check if the value is inside of the deadband range\n            if drivetrain_left_side_speed < 5 and drivetrain_left_side_speed > -5:\n                # check if the left motor has already been stopped\n                if drivetrain_l_needs_to_be_stopped_controller_1:\n                    # stop the left drive motor\n                    left_drive_smart.stop()\n                    # tell the code that the left motor has been stopped\n                    drivetrain_l_needs_to_be_stopped_controller_1 = False\n            else:\n                # reset the toggle so that the deadband code knows to stop the left motor next\n                # time the input is in the deadband range\n                drivetrain_l_needs_to_be_stopped_controller_1 = True\n            # check if the value is inside of the deadband range\n            if drivetrain_right_side_speed < 5 and drivetrain_right_side_speed > -5:\n                # check if the right motor has already been stopped\n                if drivetrain_r_needs_to_be_stopped_controller_1:\n                    # stop the right drive motor\n                    right_drive_smart.stop()\n                    # tell the code that the right motor has been stopped\n                    drivetrain_r_needs_to_be_stopped_controller_1 = False\n            else:\n                # reset the toggle so that the deadband code knows to stop the right motor next\n                # time the input is in the deadband range\n                drivetrain_r_needs_to_be_stopped_controller_1 = True\n            \n            # only tell the left drive motor to spin if the values are not in the deadband range\n            if drivetrain_l_needs_to_be_stopped_controller_1:\n                left_drive_smart.set_velocity(drivetrain_left_side_speed, PERCENT)\n                left_drive_smart.spin(FORWARD)\n            # only tell the right drive motor to spin if the values are not in the deadband range\n            if drivetrain_r_needs_to_be_stopped_controller_1:\n                right_drive_smart.set_velocity(drivetrain_right_side_speed, PERCENT)\n                right_drive_smart.spin(FORWARD)\n        # wait before repeating the process\n        wait(20, MSEC)\n\n# define variable for remote controller enable/disable\nremote_control_code_enabled = True\n\nrc_auto_loop_thread_controller_1 = Thread(rc_auto_loop_function_controller_1)\n\n#endregion VEXcode Generated Robot Configuration\n\n# ------------------------------------------\n# \n#   Project:      VEXcode Project\n#   Author:       VEX\n#   Created:\n#   Description:  VEXcode V5 Python Project\n# \n# ------------------------------------------\n\n# Library imports\nfrom vex import *\nimport math\n\n\n# Begin project code\n\nid_to_name = {\n    0: \"Mobile Goal\",\n    1: \"Red Ring\",\n    2: \"Blue Ring\"\n}\ndrive_condition = False #Right, Left, or Straight\n\n# Parameters for turning PID control\n# use for turning robot when using AI sensor\nKp = 0.15\nKi = 0.01\nKd = 0.05\n\n# Parameters for turning PID control\nturn_kP =  0.1      # Proportional constant\nturn_kI =  0.001    # Integral constant\nturn_kD =  0.0      # Derivative constant\nturn_tolerance = 1.0  # Acceptable error in degrees\nmin_turn_speed = 5  # Minimum turn speed to overcome friction\nmax_turn_speed = 50 # Maximum turn speed\n\n# PID constants for straight driving correction\n# These values need tuning for your specific robot\n# kP = 0.1  # Proportional gain\n# kI = 0.01  # Integral gain\n# kD = 0.1   # Derivative gain\n\ndrive_kP = 0.001  # Proportional gain\ndrive_kI = 0.001  # Integral gain\ndrive_kD = 0.0   # Derivative gain\n\n# Maximum allowed integral value to prevent wind-up\nMAX_INTEGRAL = 50\n\nintegral = 0\n\nprev_error = 0\n\n# drivetrain.set_turn_velocity(5, PERCENT)\n#screenshot sent from here  \ndef getdist(H_cam, H_obj, pixel_height, VFOV_deg=63, img_height_px=240):\n    # Step 1: Convert pixel height into angular size\n    VFOV_rad = math.radians(VFOV_deg)\n    alpha_rad = (pixel_height / img_height_px) * VFOV_rad\n\n    # Step 2: Estimate slant distance from angular size\n    S = H_obj / (2 * math.tan(alpha_rad / 2))\n\n    S_squared = S**2\n    H_squared = H_cam**2\n    D_horizontal = math.sqrt(abs(S_squared - H_squared))  # Use abs to protect from tiny negative values due to rounding\n\n    return D_horizontal\n\n\ndef visionAI():\n    while True:\n        ai_objects = ai_vision_12.take_snapshot(AiVision.ALL_AIOBJS)\n\n        if len(ai_objects) == 0:\n            print(\"No objects detected. Sleeping...\")\n            drivetrain.stop()\n            continue\n\n        minDist = float(\"inf\")\n        close = None\n        t_center = 160  \n\n        for obj in ai_objects:\n            if obj.exists and obj.score >= 80:\n                obj_dist = getdist(10, 2, obj.height, 63, 240)\n\n                if obj_dist < minDist:\n                    minDist = obj_dist\n                    close = obj  \n                \n        if close:\n            obj_id = close.id\n            obj_center_x = close.centerX\n            obj_center_y = close.centerY\n            obj_height = close.height\n            obj_score = close.score\n            obj_name = id_to_name.get(obj_id, \"Unknown\")\n\n            print(\"Name: \")\n            print(obj_name, \"\\n\")\n            print(\"Height: \")\n            print(obj_height, \"\\n\")\n            # print(\"Center X: \")\n            # print(obj_center_x, \"\\n\")\n            # print(\"Center Y: \")\n            # print(obj_center_y, \"\\n\")\n            print(\"Score: \")\n            print(obj_score, \"\\n\")\n\n            error = obj_center_x - t_center\n        \n\n            integral = integral + error\n\n            derivative = error - prev_error\n\n            prev_error = error\n\n            pid_out = (Kp * error) + (Ki * integral) + (Kd * derivative)\n\n            print(\"Target \", obj_name, \", X:\", obj_center_x, \", Distance:\", minDist)\n            #if i want i can print obj_center_x but its not needed for now. \n            print(\"error is:\",error)\n\n            print(\"PID OUTPUT:\", pid_out)\n\n            if abs(error) > 10: # pid_out > 10\n                if pid_out > 0:\n                    print(\"Turning RIGHT\")\n                    drive_condition = \"RIGHT\"\n                else:\n                    print(\"Turning LEFT\")\n                    drive_condition = \"LEFT\"\n            else:\n                print(\"Going STRAIGHT\")\n                drive_condition = \"STRAIGHT\"\n\n            print(\"Moving towards:\", obj_name)\n\n            if drive_condition == \"RIGHT\":\n                drivetrain.turn(RIGHT)\n                #wait(10, MSEC)\n            elif drive_condition == \"LEFT\":\n                drivetrain.turn(LEFT)\n                #wait(10, MSEC)\n            elif drive_condition == \"STRAIGHT\":\n                drivetrain.stop()\n        else:\n            drivetrain.stop()\n\n\ndef normalize_heading(heading):\n    \"\"\"Normalize heading to be between 0-360 degrees\"\"\"\n    while heading < 0:\n        heading += 360\n    while heading >= 360:\n        heading -= 360\n\n    # print(\"normalize heading: \", heading)\n    return heading\n\ndef shortest_angle_difference(target, current):\n    \"\"\"Calculate the shortest angle to turn (handles wraparound)\"\"\"\n    diff = normalize_heading(target) - normalize_heading(current)\n    \n    # Handle cases where turning the other way is shorter\n    if diff > 180:\n        diff -= 360\n    elif diff < -180:\n        diff += 360\n    \n    # print(\"shortest angle diff: \", diff)\n    return diff\n\ndef turn_to_heading(target_heading, max_speed):\n    \"\"\"\n    Turn the robot to a specific heading using PID control with GPS sensor\n    \n    Args:\n        target_heading: Target heading in degrees (0-360)\n        max_speed: Maximum turning speed (0-100)\n    \"\"\"\n    print(\"Starting turn to heading: \",target_heading,\" degrees\")\n    \n    # Normalize target heading to 0-360 range\n    target_heading = normalize_heading(target_heading)\n    \n    # PID variables\n    integral = 0\n    prev_error = 0\n    \n    # Initial error calculation\n    current_heading = gps_6.heading()\n    error = shortest_angle_difference(target_heading, current_heading)\n    \n    # Continue until we're close enough to the target\n    timer = Timer()  # Used to detect if we're stuck\n    timer.reset()\n    \n    while abs(error) > turn_tolerance:\n        # Get current heading from GPS\n        current_heading = gps_6.heading()\n        \n        # Calculate error (how far we still need to turn)\n        error = shortest_angle_difference(target_heading, current_heading)\n        \n        # Calculate integral (sum of errors over time)\n        integral += error\n        \n        # Prevent integral windup\n        if abs(integral) > 1000:\n            integral = 1000 if integral > 0 else -1000\n        \n        # If we're not making progress, reset integral\n        if timer.time(SECONDS) > 2:\n            if abs(prev_error - error) < 1:\n                integral = 0\n                print(\"Progress stalled, resetting integral\")\n            timer.reset()\n        \n        # Calculate derivative (rate of change of error)\n        derivative = error - prev_error\n        \n        # Calculate motor power using PID\n        power = (error * turn_kP) + (integral * turn_kI) + (derivative * turn_kD)\n        print (\"Power: \", power,\"error: \", error* turn_kP,\" integral: \", integral* turn_kI,\" derivative: \",derivative* turn_kD)\n        \n        # Ensure minimum power to overcome friction\n        if 0 < abs(power) < min_turn_speed:\n            power = min_turn_speed * (1 if power > 0 else -1)\n            print (\"Min Power: \", power)\n        \n        # Limit power to specified maximum\n        if abs(power) > max_speed:\n            power = max_speed * (1 if power > 0 else -1)\n            print (\"Max Power: \", power)\n        \n        # Apply motor power for turning\n        # Positive error means we need to turn clockwise\n        left_drive_smart.spin(FORWARD, power, PERCENT)\n        right_drive_smart.spin(REVERSE, power, PERCENT)\n        \n        # Debug info\n        print(\"Current: \",current_heading,\" Target: \",target_heading,\" Err: \",error,\" Power: \",power)\n        print(\"GPS Position X: \",gps_6.x_position(MM),\" mm Y: \",gps_6.y_position(MM),\" mm\\n\\n\")\n        \n        # Update previous error for next iteration\n        prev_error = error\n        \n        # Short delay to prevent CPU hogging\n        wait(20, MSEC)\n    \n    # Stop the robot once target is reached\n    left_drive_smart.stop(BRAKE)\n    right_drive_smart.stop(BRAKE)\n    print(\"Target heading reached: Current= \",gps_6.heading(),\" Target= \",target_heading)\n\ndef turn_by_angle(angle_degrees, max_speed):\n    \"\"\"\n    Turn the robot by a relative angle using the GPS sensor\n    \n    Args:\n        angle_degrees: Angle to turn in degrees (positive=clockwise, negative=counter-clockwise)\n        max_speed: Maximum turning speed (0-100)\n    \"\"\"\n    # Get current heading\n    current_heading = gps_6.heading()\n    \n    # Calculate target heading\n    target_heading = normalize_heading(current_heading + angle_degrees)\n    \n    print(\"Starting relative turn of \",angle_degrees,\" degrees\")\n    print(\"Current heading: \",current_heading,\" Target heading: \",target_heading)\n    \n    # Execute the turn\n    turn_to_heading(target_heading, max_speed)\n    wait(100,MSEC)\n\n    if(gps_6.heading() != target_heading):\n        print (\"calling again...\\nheading: \", gps_6.heading(),\" target: \", target_heading)\n        turn_to_heading(target_heading, max_speed)\n\n    if(gps_6.heading() != target_heading):\n        print (\"calling again...\\nheading: \", gps_6.heading(),\" target: \", target_heading)\n        turn_to_heading(target_heading, max_speed)\n\n    if(gps_6.heading() != target_heading):\n        print (\"calling again...\\nheading: \", gps_6.heading(),\" target: \", target_heading)\n        turn_to_heading(target_heading, max_speed)\n\n# Function to reset rotation sensors\ndef reset_rotations():\n    OdomLEFT.reset_position()\n    odomRIGHT.reset_position()\n    \n# Function to drive straight for a specific distance in degrees using PID\ndef drive_straight_pid(distance_deg, speed_pct):\n    # Reset rotation sensors\n    reset_rotations()\n    \n    # Target position and PID variables\n    target_position = abs(distance_deg)\n    direction = 1 if distance_deg > 0 else -1  # Determine direction\n    \n    # PID variables\n    prev_error = 0\n    integral = 0\n    \n    # Control loop variables\n    average_position = 0\n    last_time = brain.timer.time(MSEC)\n    \n    # Loop until we reach the target distance\n    while average_position < target_position:\n        # Calculate time delta for derivative calculation\n        current_time = brain.timer.time(MSEC)\n        dt = current_time - last_time\n        dt = max(dt, 1)  # Prevent division by zero\n        last_time = current_time\n        \n        # Get current position from both rotation sensors\n        left_position = abs(OdomLEFT.position(DEGREES))\n        right_position = abs(odomRIGHT.position(DEGREES))\n        \n        # Calculate average position and error (difference between sensors)\n        average_position = (left_position + right_position) / 2\n        position_error = left_position - right_position\n        \n        # Calculate PID components\n        # Proportional term\n        p_term = position_error * drive_kP\n        \n        # Integral term with anti-windup\n        integral += position_error * dt / 1000.0\n        integral = max(min(integral, MAX_INTEGRAL), -MAX_INTEGRAL)  # Clamp to prevent windup\n        i_term = integral * drive_kI\n        \n        # Derivative term\n        derivative = (position_error - prev_error) / (dt / 1000.0)\n        d_term = derivative * drive_kD\n        \n        # Calculate total correction\n        correction = p_term + i_term + d_term\n        \n        # Store error for next iteration\n        prev_error = position_error\n        \n        # Apply the correction to the motors\n        left_speed = speed_pct * direction + correction\n        right_speed = speed_pct * direction - correction\n        \n        # Constrain speeds to valid range (-100 to 100)\n        left_speed = max(min(left_speed, 100), -100)\n        right_speed = max(min(right_speed, 100), -100)\n        \n        # Set motor speeds\n        left_motor_a.spin(FORWARD, left_speed, PERCENT)\n        left_motor_b.spin(FORWARD, left_speed, PERCENT)\n        right_motor_a.spin(FORWARD, right_speed, PERCENT)\n        right_motor_b.spin(FORWARD, right_speed, PERCENT)\n        \n        # Small delay to avoid hogging CPU\n        wait(20, MSEC)\n        \n        # Display debug information\n        print(\"L: \",left_position,\" R: \",right_position,\" E: \",position_error,\" P: \",(average_position/target_position*100))\n        print(\"P: \",p_term,\" I: \",i_term,\" D: \",d_term,\"\\n\")\n        \n    # Stop all motors\n    left_motor_a.stop(BRAKE)\n    left_motor_b.stop(BRAKE)\n    right_motor_a.stop(BRAKE)\n    right_motor_b.stop(BRAKE)\n    \n    # brain.screen.set_cursor(6, 1)\n    # brain.screen.print(\"Drive complete!\")\n    print(\"Drive complete!\")\n    \n    return True\n\n# Function to aim for a specific distance and handle timeouts\ndef drive_distance_with_timeout(distance_deg, speed_pct, timeout_sec):\n     # Wait for rotation sensors to initialize\n    wait(100, MSEC)\n\n    # Start timer\n    timer = Timer()\n    \n    # Execute drive function with timeout\n    success = drive_straight_pid(distance_deg, speed_pct)\n    \n    # Check if timeout occurred\n    if timer.time(SECONDS) >= timeout_sec:\n        # brain.screen.set_cursor(7, 1)\n        # brain.screen.print(\"Drive timed out!\")\n        print(\"Drive timed out!\")\n        print(\"Drive complete!\")\n        \n        # Stop all motors\n        left_motor_a.stop(BRAKE)\n        left_motor_b.stop(BRAKE)\n        right_motor_a.stop(BRAKE)\n        right_motor_b.stop(BRAKE)\n        return False\n    \n    return success\n\n\nwheelDiameter=2.75 # Inches\nwheelCircumference = math.pi * wheelDiameter\ntravelDistance = 48 # Inches\nerror = 5 # inches\n\ntravelDistance -= error\n\nnumberOfDegrees = (travelDistance/wheelCircumference) * 360\nspeed = 30\n\nturnAngle = 90\n\n# Main program\ndef main():\n    # gps_18.calibrate()\n    print(\"Starting GPS navigation program\")\n    print(\"Current GPS heading: \",gps_6.heading())\n    print(\"Current GPS position: X= \",gps_6.x_position(MM), \" IN Y= \",gps_6.y_position(MM),\" IN\")\n    \n    # Allow GPS to calibrate if needed\n    wait(1, SECONDS)\n    \n    # Wait for user to press a button to start\n    print(\"Press A for absolute heading, B for relative turn, X for point navigation\")\n    \n    while True:\n        if controller_1.buttonA.pressing():\n            print(\"Button A pressed, turning to absolute heading \",turnAngle)\n            turn_to_heading(turnAngle, speed) # turn to (absolute degree, speed)\n            print (\"\\n***************************************************\")\n            turn_to_heading(turnAngle, speed) # turn to (absolute degree, speed)\n            print (\"\\n***************************************************\")\n            turn_to_heading(turnAngle, speed) # turn to (absolute degree, speed)\n            print (\"\\n***************************************************\")\n            break\n        elif controller_1.buttonB.pressing():\n            print(\"Button B pressed, turning 90° clockwise\")\n            gpsHeading = gps_6.heading()\n\n            turn_by_angle(turnAngle,speed)\n            break\n        elif controller_1.buttonX.pressing():\n            print(\"Button X pressed, driving straight\")\n            \n            # Drive forward with 5 second timeout\n            drive_distance_with_timeout(numberOfDegrees, speed, 5)\n            # break\n        wait(50, MSEC)\n    \n    print(\"Program complete\")\n\n# Run the main program\nprint(\"running main\")\nmain()\n# visionAI()","textLanguage":"python","robotConfig":[{"port":[12],"name":"ai_vision_12","customName":false,"deviceType":"AIVision","deviceClass":"aivision","setting":{"config":"{\"colors\":[],\"codes\":[],\"tags\":false,\"AIObjects\":true,\"AIObjectModel\":[\"Ball(Blue)\",\"Ball(Green)\",\"Ball(Red)\",\"Ring(Blue)\",\"Ring(Green)\",\"Ring(Red)\",\"Cube(Blue)\",\"Cube(Green)\",\"Cube(Red)\"],\"aiModelDropDownValue\":\"2024-2025 High Stakes\"}","isConfigured":"false"},"triportSourcePort":22},{"port":[3,8,4,1,0],"name":"drivetrain","customName":false,"deviceType":"Drivetrain","deviceClass":"smartdrive","setting":{"type":"4-motor","wheelSize":"wheel275in","gear":"ratio6_1","gearRatio":"16:36","direction":"rev","gyroType":"none","width":"14.5","unit":"in","wheelbase":"12.","wheelbaseUnit":"in","xOffset":"0","xOffsetUnit":"mm","yOffset":"0","yOffsetUnit":"mm","thetaOffset":"180"},"triportSourcePort":null},{"port":[],"name":"controller_1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"splitRight","id":"primary"},"triportSourcePort":22},{"port":[2],"name":"IntakeBelt","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[18],"name":"Intakewheels","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[3],"name":"MogoPiston1","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{"id":"partner"},"triportSourcePort":22},{"port":[4],"name":"MogotPiston2","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{"id":"partner"},"triportSourcePort":22},{"port":[6],"name":"CornerClear","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{"id":"partner"},"triportSourcePort":22},{"port":[19],"name":"OdomLEFT","customName":true,"deviceType":"Rotation","deviceClass":"rotation","setting":{"reversed":"false","id":"partner"},"triportSourcePort":22},{"port":[14],"name":"odomRIGHT","customName":true,"deviceType":"Rotation","deviceClass":"rotation","setting":{"reversed":"false","id":"partner"},"triportSourcePort":22},{"port":[20],"name":"intertial","customName":true,"deviceType":"Inertial","deviceClass":"inertial","setting":{"id":"partner"},"triportSourcePort":22},{"port":[6],"name":"gps_6","customName":false,"deviceType":"GPS","deviceClass":"gps","setting":{"xOffset":"4","xOffsetUnit":"in","yOffset":"-7","yOffsetUnit":"in","thetaOffset":"0"},"triportSourcePort":22}],"slot":7,"platform":"V5","sdkVersion":"20240802.15.00.00","appVersion":"4.0.7","fileFormat":"2.0.0","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false}